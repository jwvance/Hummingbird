C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USB.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\USB.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP80
                    -51\DP8051_Keil_951\Debug/USB.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USB.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: USB.c
   3          * Version 2.70
   4          *
   5          * Description:
   6          *  API for USBFS Component.
   7          *
   8          * Note:
   9          *  Many of the functions use endpoint number.  RAM arrays are sized with 9
  10          *  elements so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
  15          * You may use this file only in accordance with the license, terms, conditions,
  16          * disclaimers, and limitations in the end user license agreement accompanying
  17          * the software package with which this file was provided.
  18          *******************************************************************************/
  19          
  20          #include <CyDmac.h>
  21          #include "USB.h"
  22          #include "USB_pvt.h"
  23          #include "USB_hid.h"
  24          #if(USB_DMA1_REMOVE == 0u)
                  #include "USB_ep1_dma.h"
              #endif   /*  USB_DMA1_REMOVE */
  27          #if(USB_DMA2_REMOVE == 0u)
                  #include "USB_ep2_dma.h"
              #endif   /*  USB_DMA2_REMOVE */
  30          #if(USB_DMA3_REMOVE == 0u)
                  #include "USB_ep3_dma.h"
              #endif   /*  USB_DMA3_REMOVE */
  33          #if(USB_DMA4_REMOVE == 0u)
                  #include "USB_ep4_dma.h"
              #endif   /*  USB_DMA4_REMOVE */
  36          #if(USB_DMA5_REMOVE == 0u)
                  #include "USB_ep5_dma.h"
              #endif   /*  USB_DMA5_REMOVE */
  39          #if(USB_DMA6_REMOVE == 0u)
                  #include "USB_ep6_dma.h"
              #endif   /*  USB_DMA6_REMOVE */
  42          #if(USB_DMA7_REMOVE == 0u)
                  #include "USB_ep7_dma.h"
              #endif   /*  USB_DMA7_REMOVE */
  45          #if(USB_DMA8_REMOVE == 0u)
                  #include "USB_ep8_dma.h"
              #endif   /*  USB_DMA8_REMOVE */
  48          #if((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
                  #include "USB_EP_DMA_Done_isr.h"
                  #include "USB_EP8_DMA_Done_SR.h"
                  #include "USB_EP17_DMA_Done_SR.h"
              #endif /* ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
  53          
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 2   

  54          
  55          /***************************************
  56          * Global data allocation
  57          ***************************************/
  58          
  59          uint8 USB_initVar = 0u;
  60          #if(USB_EP_MM != USB__EP_MANUAL)
                  uint8 USB_DmaChan[USB_MAX_EP];
                  uint8 USB_DmaTd[USB_MAX_EP];
              #endif /*  USB_EP_MM */
  64          #if((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
                  static uint8 clearInDataRdyStatus = USB_ARB_EPX_CFG_DEFAULT;
                  uint8 USB_DmaNextTd[USB_MAX_EP];
                  const uint8 USB_epX_TD_TERMOUT_EN[USB_MAX_EP] =
                  {   0u,
                      USB_ep1_TD_TERMOUT_EN,
                      USB_ep2_TD_TERMOUT_EN,
                      USB_ep3_TD_TERMOUT_EN,
                      USB_ep4_TD_TERMOUT_EN,
                      USB_ep5_TD_TERMOUT_EN,
                      USB_ep6_TD_TERMOUT_EN,
                      USB_ep7_TD_TERMOUT_EN,
                      USB_ep8_TD_TERMOUT_EN
                  };
                  volatile uint16 USB_inLength[USB_MAX_EP];
                  const uint8 *USB_inDataPointer[USB_MAX_EP];
                  volatile uint8 USB_inBufFull[USB_MAX_EP];
              #endif /* ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
  82          
  83          
  84          /*******************************************************************************
  85          * Function Name: USB_Start
  86          ********************************************************************************
  87          *
  88          * Summary:
  89          *  This function initialize the USB SIE, arbiter and the
  90          *  endpoint APIs, including setting the D+ Pullup
  91          *
  92          * Parameters:
  93          *  device: Contains the device number of the desired device descriptor.
  94          *          The device number can be found in the Device Descriptor Tab of
  95          *          "Configure" dialog, under the settings of desired Device Descriptor,
  96          *          in the "Device Number" field.
  97          *  mode: The operating voltage. This determines whether the voltage regulator
  98          *        is enabled for 5V operation or if pass through mode is used for 3.3V
  99          *        operation. Symbolic names and their associated values are given in the
 100          *        following table.
 101          *       USB_3V_OPERATION - Disable voltage regulator and pass-thru
 102          *                                       Vcc for pull-up
 103          *       USB_5V_OPERATION - Enable voltage regulator and use
 104          *                                       regulator for pull-up
 105          *       USB_DWR_VDDD_OPERATION - Enable or Disable voltage
 106          *                         regulator depend on Vddd Voltage configuration in DWR.
 107          *
 108          * Return:
 109          *   None.
 110          *
 111          * Global variables:
 112          *  The USB_intiVar variable is used to indicate initial
 113          *  configuration of this component. The variable is initialized to zero (0u)
 114          *  and set to one (1u) the first time USB_Start() is called.
 115          *  This allows for component Re-Start without unnecessary re-initialization
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 3   

 116          *  in all subsequent calls to the USB_Start() routine.
 117          *  If re-initialization of the component is required the variable should be set
 118          *  to zero before call of UART_Start() routine, or the user may call
 119          *  USB_Init() and USB_InitComponent() as done
 120          *  in the USB_Start() routine.
 121          *
 122          * Side Effects:
 123          *   This function will reset all communication states to default.
 124          *
 125          * Reentrant:
 126          *  No.
 127          *
 128          *******************************************************************************/
 129          void USB_Start(uint8 device, uint8 mode) 
 130          {
 131   1          /* If not Initialized then initialize all required hardware and software */
 132   1          if(USB_initVar == 0u)
 133   1          {
 134   2              USB_Init();
 135   2              USB_initVar = 1u;
 136   2          }
 137   1          USB_InitComponent(device, mode);
 138   1      }
 139          
 140          
 141          /*******************************************************************************
 142          * Function Name: USB_Init
 143          ********************************************************************************
 144          *
 145          * Summary:
 146          *  Initialize component's hardware. Usually called in USB_Start().
 147          *
 148          * Parameters:
 149          *  None.
 150          *
 151          * Return:
 152          *  None.
 153          *
 154          * Reentrant:
 155          *  No.
 156          *
 157          *******************************************************************************/
 158          void USB_Init(void) 
 159          {
 160   1          uint8 enableInterrupts;
 161   1          #if(USB_EP_MM != USB__EP_MANUAL)
                      uint16 i;
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 164   1      
 165   1          enableInterrupts = CyEnterCriticalSection();
 166   1      
 167   1          /* Enable USB block  */
 168   1          USB_PM_ACT_CFG_REG |= USB_PM_ACT_EN_FSUSB;
 169   1          /* Enable USB block for Standby Power Mode */
 170   1          USB_PM_STBY_CFG_REG |= USB_PM_STBY_EN_FSUSB;
 171   1      
 172   1          /* Enable core clock */
 173   1          USB_USB_CLK_EN_REG = USB_USB_CLK_ENABLE;
 174   1      
 175   1          USB_CR1_REG = USB_CR1_ENABLE_LOCK;
 176   1      
 177   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE */
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 4   

 178   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled */
 179   1          USB_USBIO_CR0_REG &= ((uint8)(~USB_USBIO_CR0_TEN));
 180   1          CyDelayUs(0u);  /*~50ns delay */
 181   1          /* Disable the USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted)
 182   1          *  high. This will have been set low by the power manger out of reset.
 183   1          *  Also confirm USBIO pull-up disabled
 184   1          */
 185   1          USB_PM_USB_CR0_REG &= ((uint8)(~(USB_PM_USB_CR0_PD_N |
 186   1                                                        USB_PM_USB_CR0_PD_PULLUP_N)));
 187   1      
 188   1          /* Select iomode to USB mode*/
 189   1          USB_USBIO_CR1_REG &= ((uint8)(~USB_USBIO_CR1_IOMODE));
 190   1      
 191   1          /* Enable the USBIO reference by setting PM.USB_CR0.fsusbio_ref_en.*/
 192   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_REF_EN;
 193   1          /* The reference will be available 1 us after the regulator is enabled */
 194   1          CyDelayUs(1u);
 195   1          /* OR 40us after power restored */
 196   1          CyDelayUs(40u);
 197   1          /* Ensure the single ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 198   1          USB_DM_INP_DIS_REG &= ((uint8)(~USB_DM_MASK));
 199   1          USB_DP_INP_DIS_REG &= ((uint8)(~USB_DP_MASK));
 200   1      
 201   1          /* Enable USBIO */
 202   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_PD_N;
 203   1          CyDelayUs(2u);
 204   1          /* Set the USBIO pull-up enable */
 205   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_PD_PULLUP_N;
 206   1      
 207   1          /* Write WAx */
 208   1          CY_SET_REG8(USB_ARB_RW1_WA_PTR,     0u);
 209   1          CY_SET_REG8(USB_ARB_RW1_WA_MSB_PTR, 0u);
 210   1      
 211   1          #if(USB_EP_MM != USB__EP_MANUAL)
                      /* Init transfer descriptor. This will be used to detect the DMA state - initialized or not. */
                      for (i = 0u; i < USB_MAX_EP; i++)
                      {
                          USB_DmaTd[i] = DMA_INVALID_TD;
                          #if ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
                              USB_DmaNextTd[i] = DMA_INVALID_TD;
                          #endif /* ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      
 224   1      
 225   1          /* Set the bus reset Interrupt. */
 226   1          (void) CyIntSetVector(USB_BUS_RESET_VECT_NUM,   &USB_BUS_RESET_ISR);
 227   1          CyIntSetPriority(USB_BUS_RESET_VECT_NUM, USB_BUS_RESET_PRIOR);
 228   1      
 229   1          /* Set the SOF Interrupt. */
 230   1          #if(USB_SOF_ISR_REMOVE == 0u)
 231   1              (void) CyIntSetVector(USB_SOF_VECT_NUM,   &USB_SOF_ISR);
 232   1              CyIntSetPriority(USB_SOF_VECT_NUM, USB_SOF_PRIOR);
 233   1          #endif   /*  USB_SOF_ISR_REMOVE */
 234   1      
 235   1          /* Set the Control Endpoint Interrupt. */
 236   1          (void) CyIntSetVector(USB_EP_0_VECT_NUM,   &USB_EP_0_ISR);
 237   1          CyIntSetPriority(USB_EP_0_VECT_NUM, USB_EP_0_PRIOR);
 238   1      
 239   1          /* Set the Data Endpoint 1 Interrupt. */
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 5   

 240   1          #if(USB_EP1_ISR_REMOVE == 0u)
 241   1              (void) CyIntSetVector(USB_EP_1_VECT_NUM,   &USB_EP_1_ISR);
 242   1              CyIntSetPriority(USB_EP_1_VECT_NUM, USB_EP_1_PRIOR);
 243   1          #endif   /*  USB_EP1_ISR_REMOVE */
 244   1      
 245   1          /* Set the Data Endpoint 2 Interrupt. */
 246   1          #if(USB_EP2_ISR_REMOVE == 0u)
 247   1              (void) CyIntSetVector(USB_EP_2_VECT_NUM,   &USB_EP_2_ISR);
 248   1              CyIntSetPriority(USB_EP_2_VECT_NUM, USB_EP_2_PRIOR);
 249   1          #endif   /*  USB_EP2_ISR_REMOVE */
 250   1      
 251   1          /* Set the Data Endpoint 3 Interrupt. */
 252   1          #if(USB_EP3_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_3_VECT_NUM,   &USB_EP_3_ISR);
                      CyIntSetPriority(USB_EP_3_VECT_NUM, USB_EP_3_PRIOR);
                  #endif   /*  USB_EP3_ISR_REMOVE */
 256   1      
 257   1          /* Set the Data Endpoint 4 Interrupt. */
 258   1          #if(USB_EP4_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_4_VECT_NUM,   &USB_EP_4_ISR);
                      CyIntSetPriority(USB_EP_4_VECT_NUM, USB_EP_4_PRIOR);
                  #endif   /*  USB_EP4_ISR_REMOVE */
 262   1      
 263   1          /* Set the Data Endpoint 5 Interrupt. */
 264   1          #if(USB_EP5_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_5_VECT_NUM,   &USB_EP_5_ISR);
                      CyIntSetPriority(USB_EP_5_VECT_NUM, USB_EP_5_PRIOR);
                  #endif   /*  USB_EP5_ISR_REMOVE */
 268   1      
 269   1          /* Set the Data Endpoint 6 Interrupt. */
 270   1          #if(USB_EP6_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_6_VECT_NUM,   &USB_EP_6_ISR);
                      CyIntSetPriority(USB_EP_6_VECT_NUM, USB_EP_6_PRIOR);
                  #endif   /*  USB_EP6_ISR_REMOVE */
 274   1      
 275   1           /* Set the Data Endpoint 7 Interrupt. */
 276   1          #if(USB_EP7_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_7_VECT_NUM,   &USB_EP_7_ISR);
                      CyIntSetPriority(USB_EP_7_VECT_NUM, USB_EP_7_PRIOR);
                  #endif   /*  USB_EP7_ISR_REMOVE */
 280   1      
 281   1          /* Set the Data Endpoint 8 Interrupt. */
 282   1          #if(USB_EP8_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USB_EP_8_VECT_NUM,   &USB_EP_8_ISR);
                      CyIntSetPriority(USB_EP_8_VECT_NUM, USB_EP_8_PRIOR);
                  #endif   /*  USB_EP8_ISR_REMOVE */
 286   1      
 287   1          #if((USB_EP_MM != USB__EP_MANUAL) && (USB_ARB_ISR_REMOVE == 0u))
                      /* Set the ARB Interrupt. */
                      (void) CyIntSetVector(USB_ARB_VECT_NUM,   &USB_ARB_ISR);
                      CyIntSetPriority(USB_ARB_VECT_NUM, USB_ARB_PRIOR);
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 292   1      
 293   1      }
 294          
 295          
 296          /*******************************************************************************
 297          * Function Name: USB_InitComponent
 298          ********************************************************************************
 299          *
 300          * Summary:
 301          *  Initialize the component, except for the HW which is done one time in
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 6   

 302          *  the Start function.  This function pulls up D+.
 303          *
 304          * Parameters:
 305          *  device: Contains the device number of the desired device descriptor.
 306          *          The device number can be found in the Device Descriptor Tab of
 307          *          "Configure" dialog, under the settings of desired Device Descriptor,
 308          *          in the "Device Number" field.
 309          *  mode: The operating voltage. This determines whether the voltage regulator
 310          *        is enabled for 5V operation or if pass through mode is used for 3.3V
 311          *        operation. Symbolic names and their associated values are given in the
 312          *        following table.
 313          *       USB_3V_OPERATION - Disable voltage regulator and pass-thru
 314          *                                       Vcc for pull-up
 315          *       USB_5V_OPERATION - Enable voltage regulator and use
 316          *                                       regulator for pull-up
 317          *       USB_DWR_VDDD_OPERATION - Enable or Disable voltage
 318          *                         regulator depend on Vddd Voltage configuration in DWR.
 319          *
 320          * Return:
 321          *   None.
 322          *
 323          * Global variables:
 324          *   USB_device: Contains the device number of the desired device
 325          *       descriptor. The device number can be found in the Device Descriptor Tab
 326          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 327          *       in the "Device Number" field.
 328          *   USB_transferState: This variable used by the communication
 329          *       functions to handle current transfer state. Initialized to
 330          *       TRANS_STATE_IDLE in this API.
 331          *   USB_configuration: Contains current configuration number
 332          *       which is set by the Host using SET_CONFIGURATION request.
 333          *       Initialized to zero in this API.
 334          *   USB_deviceAddress: Contains current device address. This
 335          *       variable is initialized to zero in this API. Host starts to communicate
 336          *      to device with address 0 and then set it to whatever value using
 337          *      SET_ADDRESS request.
 338          *   USB_deviceStatus: initialized to 0.
 339          *       This is two bit variable which contain power status in first bit
 340          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 341          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 342          *   USB_lastPacketSize initialized to 0;
 343          *
 344          * Reentrant:
 345          *  No.
 346          *
 347          *******************************************************************************/
 348          void USB_InitComponent(uint8 device, uint8 mode) 
 349          {
 350   1          /* Initialize _hidProtocol variable to comply with
 351   1          *  HID 7.2.6 Set_Protocol Request:
 352   1          *  "When initialized, all devices default to report protocol."
 353   1          */
 354   1          #if defined(USB_ENABLE_HID_CLASS)
                      uint8 i;
              
                      for (i = 0u; i < USB_MAX_INTERFACES_NUMBER; i++)
                      {
                          USB_hidProtocol[i] = USB_PROTOCOL_REPORT;
                      }
                  #endif /* USB_ENABLE_HID_CLASS */
 362   1      
 363   1          /* Enable Interrupts. */
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 7   

 364   1          CyIntEnable(USB_BUS_RESET_VECT_NUM);
 365   1          CyIntEnable(USB_EP_0_VECT_NUM);
 366   1          #if(USB_EP1_ISR_REMOVE == 0u)
 367   1              CyIntEnable(USB_EP_1_VECT_NUM);
 368   1          #endif   /*  USB_EP1_ISR_REMOVE */
 369   1          #if(USB_EP2_ISR_REMOVE == 0u)
 370   1              CyIntEnable(USB_EP_2_VECT_NUM);
 371   1          #endif   /*  USB_EP2_ISR_REMOVE */
 372   1          #if(USB_EP3_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_3_VECT_NUM);
                  #endif   /*  USB_EP3_ISR_REMOVE */
 375   1          #if(USB_EP4_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_4_VECT_NUM);
                  #endif   /*  USB_EP4_ISR_REMOVE */
 378   1          #if(USB_EP5_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_5_VECT_NUM);
                  #endif   /*  USB_EP5_ISR_REMOVE */
 381   1          #if(USB_EP6_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_6_VECT_NUM);
                  #endif   /*  USB_EP6_ISR_REMOVE */
 384   1          #if(USB_EP7_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_7_VECT_NUM);
                  #endif   /*  USB_EP7_ISR_REMOVE */
 387   1          #if(USB_EP8_ISR_REMOVE == 0u)
                      CyIntEnable(USB_EP_8_VECT_NUM);
                  #endif   /*  USB_EP8_ISR_REMOVE */
 390   1          #if((USB_EP_MM != USB__EP_MANUAL) && (USB_ARB_ISR_REMOVE == 0u))
                      /* usb arb interrupt enable */
                      USB_ARB_INT_EN_REG = USB_ARB_INT_MASK;
                      CyIntEnable(USB_ARB_VECT_NUM);
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 395   1      
 396   1          /* Arbiter configuration for DMA transfers */
 397   1          #if(USB_EP_MM != USB__EP_MANUAL)
                      #if(USB_EP_MM == USB__EP_DMAMANUAL)
                          USB_ARB_CFG_REG = USB_ARB_CFG_MANUAL_DMA;
                      #endif   /*  USB_EP_MM == USB__EP_DMAMANUAL */
                      #if(USB_EP_MM == USB__EP_DMAAUTO)
                          /*Set cfg cmplt this rises DMA request when the full configuration is done */
                          USB_ARB_CFG_REG = USB_ARB_CFG_AUTO_DMA | USB_ARB_CFG_AUTO_MEM;
                          #if(USB_EP_DMA_AUTO_OPT == 0u)
                              /* Init interrupt which handles verification of the successful DMA transaction */
                              USB_EP_DMA_Done_isr_StartEx(USB_EP_DMA_DONE_ISR);
                              USB_EP17_DMA_Done_SR_InterruptEnable();
                              USB_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* USB_EP_DMA_AUTO_OPT == 0u */
                      #endif   /*  USB_EP_MM == USB__EP_DMAAUTO */
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 412   1      
 413   1          USB_transferState = USB_TRANS_STATE_IDLE;
 414   1      
 415   1          /* USB Locking: Enabled, VRegulator: depend on mode or DWR Voltage configuration*/
 416   1          switch(mode)
 417   1          {
 418   2              case USB_3V_OPERATION:
 419   2                  USB_CR1_REG = USB_CR1_ENABLE_LOCK;
 420   2                  break;
 421   2              case USB_5V_OPERATION:
 422   2                  USB_CR1_REG = USB_CR1_ENABLE_LOCK | USB_CR1_REG_ENABLE;
 423   2                  break;
 424   2              default:   /*USB_DWR_VDDD_OPERATION */
 425   2                  #if(USB_VDDD_MV < USB_3500MV)
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 8   

                              USB_CR1_REG = USB_CR1_ENABLE_LOCK;
                          #else
 428   2                      USB_CR1_REG = USB_CR1_ENABLE_LOCK | USB_CR1_REG_ENABLE;
 429   2                  #endif /*  USB_VDDD_MV < USB_3500MV */
 430   2                  break;
 431   2          }
 432   1      
 433   1          /* Record the descriptor selection */
 434   1          USB_device = device;
 435   1      
 436   1          /* Clear all of the component data */
 437   1          USB_configuration = 0u;
 438   1          USB_interfaceNumber = 0u;
 439   1          USB_configurationChanged = 0u;
 440   1          USB_deviceAddress  = 0u;
 441   1          USB_deviceStatus = 0u;
 442   1      
 443   1          USB_lastPacketSize = 0u;
 444   1      
 445   1          /*  ACK Setup, Stall IN/OUT */
 446   1          CY_SET_REG8(USB_EP0_CR_PTR, USB_MODE_STALL_IN_OUT);
 447   1      
 448   1          /* Enable the SIE with an address 0 */
 449   1          CY_SET_REG8(USB_CR0_PTR, USB_CR0_ENABLE);
 450   1      
 451   1          /* Workaround for PSOC5LP */
 452   1          CyDelayCycles(1u);
 453   1      
 454   1          /* Finally, Enable d+ pullup and select iomode to USB mode*/
 455   1          CY_SET_REG8(USB_USBIO_CR1_PTR, USB_USBIO_CR1_USBPUEN);
 456   1      }
 457          
 458          
 459          /*******************************************************************************
 460          * Function Name: USB_ReInitComponent
 461          ********************************************************************************
 462          *
 463          * Summary:
 464          *  This function reinitialize the component configuration and is
 465          *  intend to be called from the Reset interrupt.
 466          *
 467          * Parameters:
 468          *  None.
 469          *
 470          * Return:
 471          *   None.
 472          *
 473          * Global variables:
 474          *   USB_device: Contains the device number of the desired device
 475          *        descriptor. The device number can be found in the Device Descriptor Tab
 476          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 477          *       in the "Device Number" field.
 478          *   USB_transferState: This variable used by the communication
 479          *       functions to handle current transfer state. Initialized to
 480          *       TRANS_STATE_IDLE in this API.
 481          *   USB_configuration: Contains current configuration number
 482          *       which is set by the Host using SET_CONFIGURATION request.
 483          *       Initialized to zero in this API.
 484          *   USB_deviceAddress: Contains current device address. This
 485          *       variable is initialized to zero in this API. Host starts to communicate
 486          *      to device with address 0 and then set it to whatever value using
 487          *      SET_ADDRESS request.
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 9   

 488          *   USB_deviceStatus: initialized to 0.
 489          *       This is two bit variable which contain power status in first bit
 490          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 491          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 492          *   USB_lastPacketSize initialized to 0;
 493          *
 494          * Reentrant:
 495          *  No.
 496          *
 497          *******************************************************************************/
 498          void USB_ReInitComponent(void) 
 499          {
 500   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
 501   1          *  Request: "When initialized, all devices default to report protocol."
 502   1          */
 503   1          #if defined(USB_ENABLE_HID_CLASS)
                      uint8 i;
              
                      for (i = 0u; i < USB_MAX_INTERFACES_NUMBER; i++)
                      {
                          USB_hidProtocol[i] = USB_PROTOCOL_REPORT;
                      }
                  #endif /* USB_ENABLE_HID_CLASS */
 511   1      
 512   1          USB_transferState = USB_TRANS_STATE_IDLE;
 513   1      
 514   1          /* Clear all of the component data */
 515   1          USB_configuration = 0u;
 516   1          USB_interfaceNumber = 0u;
 517   1          USB_configurationChanged = 0u;
 518   1          USB_deviceAddress  = 0u;
 519   1          USB_deviceStatus = 0u;
 520   1      
 521   1          USB_lastPacketSize = 0u;
 522   1      
 523   1      
 524   1          /*  ACK Setup, Stall IN/OUT */
 525   1          CY_SET_REG8(USB_EP0_CR_PTR, USB_MODE_STALL_IN_OUT);
 526   1      
 527   1          /* Enable the SIE with an address 0 */
 528   1          CY_SET_REG8(USB_CR0_PTR, USB_CR0_ENABLE);
 529   1      
 530   1      }
 531          
 532          
 533          /*******************************************************************************
 534          * Function Name: USB_Stop
 535          ********************************************************************************
 536          *
 537          * Summary:
 538          *  This function shuts down the USB function including to release
 539          *  the D+ Pullup and disabling the SIE.
 540          *
 541          * Parameters:
 542          *  None.
 543          *
 544          * Return:
 545          *  None.
 546          *
 547          * Global variables:
 548          *   USB_configuration: Contains current configuration number
 549          *       which is set by the Host using SET_CONFIGURATION request.
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 10  

 550          *       Initialized to zero in this API.
 551          *   USB_deviceAddress: Contains current device address. This
 552          *       variable is initialized to zero in this API. Host starts to communicate
 553          *      to device with address 0 and then set it to whatever value using
 554          *      SET_ADDRESS request.
 555          *   USB_deviceStatus: initialized to 0.
 556          *       This is two bit variable which contain power status in first bit
 557          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 558          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 559          *   USB_configurationChanged: This variable is set to one after
 560          *       SET_CONFIGURATION request and cleared in this function.
 561          *   USB_intiVar variable is set to zero
 562          *
 563          *******************************************************************************/
 564          void USB_Stop(void) 
 565          {
 566   1      
 567   1          #if(USB_EP_MM != USB__EP_MANUAL)
                      USB_Stop_DMA(USB_MAX_EP);     /* Stop all DMAs */
                  #endif   /*  USB_EP_MM != USB__EP_MANUAL */
 570   1      
 571   1          /* Disable the SIE */
 572   1          USB_CR0_REG &= (uint8)(~USB_CR0_ENABLE);
 573   1          /* Disable the d+ pullup */
 574   1          USB_USBIO_CR1_REG &= (uint8)(~USB_USBIO_CR1_USBPUEN);
 575   1          /* Disable USB in ACT PM */
 576   1          USB_PM_ACT_CFG_REG &= (uint8)(~USB_PM_ACT_EN_FSUSB);
 577   1          /* Disable USB block for Standby Power Mode */
 578   1          USB_PM_STBY_CFG_REG &= (uint8)(~USB_PM_STBY_EN_FSUSB);
 579   1      
 580   1          /* Disable the reset and EP interrupts */
 581   1          CyIntDisable(USB_BUS_RESET_VECT_NUM);
 582   1          CyIntDisable(USB_EP_0_VECT_NUM);
 583   1          #if(USB_EP1_ISR_REMOVE == 0u)
 584   1              CyIntDisable(USB_EP_1_VECT_NUM);
 585   1          #endif   /*  USB_EP1_ISR_REMOVE */
 586   1          #if(USB_EP2_ISR_REMOVE == 0u)
 587   1              CyIntDisable(USB_EP_2_VECT_NUM);
 588   1          #endif   /*  USB_EP2_ISR_REMOVE */
 589   1          #if(USB_EP3_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_3_VECT_NUM);
                  #endif   /*  USB_EP3_ISR_REMOVE */
 592   1          #if(USB_EP4_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_4_VECT_NUM);
                  #endif   /*  USB_EP4_ISR_REMOVE */
 595   1          #if(USB_EP5_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_5_VECT_NUM);
                  #endif   /*  USB_EP5_ISR_REMOVE */
 598   1          #if(USB_EP6_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_6_VECT_NUM);
                  #endif   /*  USB_EP6_ISR_REMOVE */
 601   1          #if(USB_EP7_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_7_VECT_NUM);
                  #endif   /*  USB_EP7_ISR_REMOVE */
 604   1          #if(USB_EP8_ISR_REMOVE == 0u)
                      CyIntDisable(USB_EP_8_VECT_NUM);
                  #endif   /*  USB_EP8_ISR_REMOVE */
 607   1      
 608   1          /* Clear all of the component data */
 609   1          USB_configuration = 0u;
 610   1          USB_interfaceNumber = 0u;
 611   1          USB_configurationChanged = 0u;
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 11  

 612   1          USB_deviceAddress  = 0u;
 613   1          USB_deviceStatus = 0u;
 614   1          USB_initVar = 0u;
 615   1      
 616   1      }
 617          
 618          
 619          /*******************************************************************************
 620          * Function Name: USB_CheckActivity
 621          ********************************************************************************
 622          *
 623          * Summary:
 624          *  Returns the activity status of the bus.  Clears the status hardware to
 625          *  provide fresh activity status on the next call of this routine.
 626          *
 627          * Parameters:
 628          *  None.
 629          *
 630          * Return:
 631          *  1 - If bus activity was detected since the last call to this function
 632          *  0 - If bus activity not was detected since the last call to this function
 633          *
 634          *******************************************************************************/
 635          uint8 USB_CheckActivity(void) 
 636          {
 637   1          uint8 r;
 638   1      
 639   1          r = CY_GET_REG8(USB_CR1_PTR);
 640   1          CY_SET_REG8(USB_CR1_PTR, (r & ((uint8)(~USB_CR1_BUS_ACTIVITY))));
 641   1      
 642   1          return((r & USB_CR1_BUS_ACTIVITY) >> USB_CR1_BUS_ACTIVITY_SHIFT);
 643   1      }
 644          
 645          
 646          /*******************************************************************************
 647          * Function Name: USB_GetConfiguration
 648          ********************************************************************************
 649          *
 650          * Summary:
 651          *  Returns the current configuration setting
 652          *
 653          * Parameters:
 654          *  None.
 655          *
 656          * Return:
 657          *  configuration.
 658          *
 659          *******************************************************************************/
 660          uint8 USB_GetConfiguration(void) 
 661          {
 662   1          return(USB_configuration);
 663   1      }
 664          
 665          
 666          /*******************************************************************************
 667          * Function Name: USB_IsConfigurationChanged
 668          ********************************************************************************
 669          *
 670          * Summary:
 671          *  Returns the clear on read configuration state. It is usefull when PC send
 672          *  double SET_CONFIGURATION request with same configuration number.
 673          *
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 12  

 674          * Parameters:
 675          *  None.
 676          *
 677          * Return:
 678          *  Not zero value when new configuration has been changed, otherwise zero is
 679          *  returned.
 680          *
 681          * Global variables:
 682          *   USB_configurationChanged: This variable is set to one after
 683          *       SET_CONFIGURATION request and cleared in this function.
 684          *
 685          *******************************************************************************/
 686          uint8 USB_IsConfigurationChanged(void) 
 687          {
 688   1          uint8 res = 0u;
 689   1      
 690   1          if(USB_configurationChanged != 0u)
 691   1          {
 692   2              res = USB_configurationChanged;
 693   2              USB_configurationChanged = 0u;
 694   2          }
 695   1      
 696   1          return(res);
 697   1      }
 698          
 699          
 700          /*******************************************************************************
 701          * Function Name: USB_GetInterfaceSetting
 702          ********************************************************************************
 703          *
 704          * Summary:
 705          *  Returns the alternate setting from current interface
 706          *
 707          * Parameters:
 708          *  uint8 interfaceNumber, interface number
 709          *
 710          * Return:
 711          *  Alternate setting.
 712          *
 713          *******************************************************************************/
 714          uint8  USB_GetInterfaceSetting(uint8 interfaceNumber)
 715                                                              
 716          {
 717   1          return(USB_interfaceSetting[interfaceNumber]);
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: USB_GetEPState
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Returned the state of the requested endpoint.
 727          *
 728          * Parameters:
 729          *  epNumber: Endpoint Number
 730          *
 731          * Return:
 732          *  State of the requested endpoint.
 733          *
 734          *******************************************************************************/
 735          uint8 USB_GetEPState(uint8 epNumber) CYREENTRANT
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 13  

 736          {
 737   1          return(USB_EP[epNumber].apiEpState);
 738   1      }
 739          
 740          
 741          /*******************************************************************************
 742          * Function Name: USB_GetEPCount
 743          ********************************************************************************
 744          *
 745          * Summary:
 746          *  This function supports Data Endpoints only(EP1-EP8).
 747          *  Returns the transfer count for the requested endpoint.  The value from
 748          *  the count registers includes 2 counts for the two byte checksum of the
 749          *  packet.  This function subtracts the two counts.
 750          *
 751          * Parameters:
 752          *  epNumber: Data Endpoint Number.
 753          *            Valid values are between 1 and 8.
 754          *
 755          * Return:
 756          *  Returns the current byte count from the specified endpoint or 0 for an
 757          *  invalid endpoint.
 758          *
 759          *******************************************************************************/
 760          uint16 USB_GetEPCount(uint8 epNumber) CYREENTRANT
 761          {
 762   1          uint8 ri;
 763   1          uint16 result = 0u;
 764   1      
 765   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
 766   1          {
 767   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
 768   2      
 769   2              result = (uint8)(CY_GET_REG8((reg8 *)(USB_SIE_EP1_CNT0_IND + ri)) &
 770   2                                USB_EPX_CNT0_MASK);
 771   2              result = (result << 8u) | CY_GET_REG8((reg8 *)(USB_SIE_EP1_CNT1_IND + ri));
 772   2              result -= USB_EPX_CNTX_CRC_COUNT;
 773   2          }
 774   1          return(result);
 775   1      }
 776          
 777          
 778          #if(USB_EP_MM != USB__EP_MANUAL)
              
              
                  /*******************************************************************************
                  * Function Name: USB_InitEP_DMA
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USB_LoadInEP() or USB_ReadOutEP() APIs for data
                  *  transfer.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  *pData: Pointer to a data array that is related to the EP transfers.
                  *
                  * Return:
                  *  None.
                  *
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 14  

                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USB_InitEP_DMA(uint8 epNumber, const uint8* pData)
                                                                                  CYREENTRANT
                  {
                      uint16 src;
                      uint16 dst;
                      #if (CY_PSOC3)                  /* PSoC 3 */
                          src = HI16(CYDEV_SRAM_BASE);
                          dst = HI16(CYDEV_PERIPH_BASE);
                          pData = pData;
                      #else                           /* PSoC 5 */
                          if((USB_EP[epNumber].addr & USB_DIR_IN) != 0u )
                          {   /* for the IN EP source is the SRAM memory buffer */
                              src = HI16(pData);
                              dst = HI16(CYDEV_PERIPH_BASE);
                          }
                          else
                          {   /* for the OUT EP source is the SIE register */
                              src = HI16(CYDEV_PERIPH_BASE);
                              dst = HI16(pData);
                          }
                      #endif  /*  C51 */
                      switch(epNumber)
                      {
                          case USB_EP1:
                              #if(USB_DMA1_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep1_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA1_REMOVE */
                              break;
                          case USB_EP2:
                              #if(USB_DMA2_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep2_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA2_REMOVE */
                              break;
                          case USB_EP3:
                              #if(USB_DMA3_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep3_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA3_REMOVE */
                              break;
                          case USB_EP4:
                              #if(USB_DMA4_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep4_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA4_REMOVE */
                              break;
                          case USB_EP5:
                              #if(USB_DMA5_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep5_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA5_REMOVE */
                              break;
                          case USB_EP6:
                              #if(USB_DMA6_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep6_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA6_REMOVE */
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 15  

                              break;
                          case USB_EP7:
                              #if(USB_DMA7_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep7_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA7_REMOVE */
                              break;
                          case USB_EP8:
                              #if(USB_DMA8_REMOVE == 0u)
                                  USB_DmaChan[epNumber] = USB_ep8_DmaInitialize(
                                      USB_DMA_BYTES_PER_BURST, USB_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USB_DMA8_REMOVE */
                              break;
                          default:
                              /* Do not support EP0 DMA transfers */
                              break;
                      }
                      if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
                      {
                          USB_DmaTd[epNumber] = CyDmaTdAllocate();
                          #if ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
                              USB_DmaNextTd[epNumber] = CyDmaTdAllocate();
                          #endif /*  ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
              
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: USB_Stop_DMA
                  ********************************************************************************
                  *
                  * Summary: Stops and free DMA
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number or
                  *           USB_MAX_EP to stop all DMAs
                  *
                  * Return:
                  *  None.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USB_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
                      i = (epNumber < USB_MAX_EP) ? epNumber : USB_EP1;
                      do
                      {
                          if(USB_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USB_DmaChan[i]);
                              CyDmaTdFree(USB_DmaTd[i]);
                              USB_DmaTd[i] = DMA_INVALID_TD;
                          }
                          #if ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
                              if(USB_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USB_DmaNextTd[i]);
                                  USB_DmaNextTd[i] = DMA_INVALID_TD;
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 16  

                              }
                          #endif /* ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
                          i++;
                      }while((i < USB_MAX_EP) && (epNumber == USB_MAX_EP));
                  }
              
              #endif /*  USB_EP_MM != USB__EP_MANUAL */
 929          
 930          
 931          #if ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u))
              
              
                  /*******************************************************************************
                  * Function Name: USB_LoadNextInEP
                  ********************************************************************************
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void USB_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if(mode == 0u)
                      {
                          /* Configure DMA to send the the rest of data */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USB_inLength[epNumber] - USB_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USB_inDataPointer[epNumber] +
                                                          USB_DMA_BYTES_PER_BURST));
                          USB_inBufFull[epNumber] = 1u;
                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USB_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USB_inDataPointer[epNumber] +
                                                 USB_DMA_BYTES_PER_BURST - USB_DMA_BYTES_REPEAT));
                      }
              
                      /* CyDmaChSetInitialTd API is optimised to init TD */
                      CY_DMA_CH_STRUCT_PTR[USB_DmaChan[epNumber]].basic_status[1u] = USB_DmaTd[epNumber];
                  }
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 17  

              #endif /* ((USB_EP_MM == USB__EP_DMAAUTO) && (USB_EP_DMA_AUTO_OPT == 0u)) */
 985          
 986          
 987          /*******************************************************************************
 988          * Function Name: USB_LoadInEP
 989          ********************************************************************************
 990          *
 991          * Summary:
 992          *  Loads and enables the specified USB data endpoint for an IN transfer.
 993          *
 994          * Parameters:
 995          *  epNumber: Contains the data endpoint number.
 996          *            Valid values are between 1 and 8.
 997          *  *pData: A pointer to a data array from which the data for the endpoint space
 998          *          is loaded.
 999          *  length: The number of bytes to transfer from the array and then send as a
1000          *          result of an IN request. Valid values are between 0 and 512.
1001          *
1002          * Return:
1003          *  None.
1004          *
1005          * Reentrant:
1006          *  No.
1007          *
1008          *******************************************************************************/
1009          void USB_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1010                                                                                  CYREENTRANT
1011          {
1012   1          uint8 ri;
1013   1          reg8 *p;
1014   1          #if(USB_EP_MM == USB__EP_MANUAL)
1015   1              uint16 i;
1016   1          #endif /*  USB_EP_MM == USB__EP_MANUAL */
1017   1      
1018   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
1019   1          {
1020   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
1021   2              p = (reg8 *)(USB_ARB_RW1_DR_IND + ri);
1022   2      
1023   2              #if(USB_EP_MM != USB__EP_DMAAUTO)
1024   2                  /* Limits length to available buffer space, auto MM could send packets up to 1024 bytes */
1025   2                  if(length > (USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset))
1026   2                  {
1027   3                      length = USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset;
1028   3                  }
1029   2              #endif /*  USB_EP_MM != USB__EP_DMAAUTO */
1030   2      
1031   2              /* Set the count and data toggle */
1032   2              CY_SET_REG8((reg8 *)(USB_SIE_EP1_CNT0_IND + ri),
1033   2                                  (length >> 8u) | (USB_EP[epNumber].epToggle));
1034   2              CY_SET_REG8((reg8 *)(USB_SIE_EP1_CNT1_IND + ri),  length & 0xFFu);
1035   2      
1036   2              #if(USB_EP_MM == USB__EP_MANUAL)
1037   2                  if(pData != NULL)
1038   2                  {
1039   3                      /* Copy the data using the arbiter data register */
1040   3                      for (i = 0u; i < length; i++)
1041   3                      {
1042   4                          CY_SET_REG8(p, pData[i]);
1043   4                      }
1044   3                  }
1045   2                  USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 18  

1046   2                  /* Write the Mode register */
1047   2                  CY_SET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri), USB_EP[epNumber].epMode);
1048   2              #else
                          /* Init DMA if it was not initialized */
                          if (USB_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USB_InitEP_DMA(epNumber, pData);
                          }
                      #endif /*  USB_EP_MM == USB__EP_MANUAL */
1055   2      
1056   2              #if(USB_EP_MM == USB__EP_DMAMANUAL)
                          USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
                          if ((pData != NULL) && (length > 0u))
                          {
                              /* Enable DMA in mode2 for transferring data */
                              (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
                                                                                               TD_TERMIN_EN | TD_INC_SRC
             -_ADR);
                              (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                              /* Generate DMA request */
                              * (reg8 *)(USB_ARB_EP1_CFG_IND + ri) |= USB_ARB_EPX_CFG_DMA_REQ;
                              * (reg8 *)(USB_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USB_ARB_EPX_CFG_DMA_REQ));
                              /* Mode register will be written in arb ISR after DMA transfer complete */
                          }
                          else
                          {
                              /* When zero-length packet - write the Mode register directly */
                              CY_SET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri), USB_EP[epNumber].epMode);
                          }
                      #endif /*  USB_EP_MM == USB__EP_DMAMANUAL */
1079   2      
1080   2              #if(USB_EP_MM == USB__EP_DMAAUTO)
                          if (pData != NULL)
                          {
                              /* Enable DMA in mode3 for transferring data */
                              (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                          #if (USB_EP_DMA_AUTO_OPT == 0u)
                              USB_inLength[epNumber] = length;
                              USB_inDataPointer[epNumber] = pData;
                              /* Configure DMA to send the data only for the first burst */
                              (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber],
                                  (length > USB_DMA_BYTES_PER_BURST) ? USB_DMA_BYTES_PER_BURST : length,
                                  USB_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
                              /* The second TD will be executed only when the first one fails.
                              *  The intention of this TD is to generate NRQ interrupt
                              *  and repeat 2 last bytes of the first burst.
                              */
                              (void) CyDmaTdSetConfiguration(USB_DmaNextTd[epNumber], 1u,
                                                             USB_DmaNextTd[epNumber],
                                                             USB_epX_TD_TERMOUT_EN[epNumber]);
                              /* Configure DmaNextTd to clear Data ready status */
                              (void) CyDmaTdSetAddress(USB_DmaNextTd[epNumber],  LO16((uint32)&clearInDataRdyStatus),
                                                                              LO16((uint32)(USB_ARB_EP1_CFG_IND + ri)));
                          #else /* Configure DMA to send all data*/
                              (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length,
                                                             USB_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 19  

                          #endif /* USB_EP_DMA_AUTO_OPT == 0u */    
              
                              /* Clear Any potential pending DMA requests before starting the DMA channel to transfer da
             -ta */
                              (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                          }
                          else
                          {
                              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
                              if(length > 0u)
                              {
                              #if (USB_EP_DMA_AUTO_OPT == 0u)
                                  USB_inLength[epNumber] = length;
                                  USB_inBufFull[epNumber] = 0u;
                                  (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                                  /* Configure DMA to send the data only for the first burst */
                                  (void) CyDmaTdSetConfiguration(
                                      USB_DmaTd[epNumber], (length > USB_DMA_BYTES_PER_BURST) ?
                                      USB_DMA_BYTES_PER_BURST : length,
                                      USB_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],
                                                           LO16((uint32)USB_inDataPointer[epNumber]), LO16((uint32)p));
                                  /* Clear Any potential pending DMA requests before starting the DMA channel to transfe
             -r data */
                                  (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
                                  /* Enable the DMA */
                                  (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                              #endif /* (USB_EP_DMA_AUTO_OPT == 0u) */
              
                                  /* Set Data ready status, This will generate DMA request */
                                  #ifndef USB_MANUAL_IN_EP_ARM
                                      * (reg8 *)(USB_ARB_EP1_CFG_IND + ri) |= USB_ARB_EPX_CFG_IN_DATA_RDY;
                                  #endif  /* USB_MANUAL_IN_EP_ARM */
                                  /* Mode register will be written in arb ISR(In Buffer Full) after first DMA transfer c
             -omplete */
                              }
                              else
                              {
                                  /* When zero-length packet - write the Mode register directly */
                                  CY_SET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri), USB_EP[epNumber].epMode);
                              }
                          }
                      #endif /*  USB_EP_MM == USB__EP_DMAAUTO */
1151   2          }
1152   1      }
1153          
1154          
1155          /*******************************************************************************
1156          * Function Name: USB_ReadOutEP
1157          ********************************************************************************
1158          *
1159          * Summary:
1160          *  Read data from an endpoint.  The application must call
1161          *  USB_GetEPState to see if an event is pending.
1162          *
1163          * Parameters:
1164          *  epNumber: Contains the data endpoint number.
1165          *            Valid values are between 1 and 8.
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 20  

1166          *  pData: A pointer to a data array from which the data for the endpoint space
1167          *         is loaded.
1168          *  length: The number of bytes to transfer from the USB Out endpoint and loads
1169          *          it into data array. Valid values are between 0 and 1023. The function
1170          *          moves fewer than the requested number of bytes if the host sends
1171          *          fewer bytes than requested.
1172          *
1173          * Returns:
1174          *  Number of bytes received, 0 for an invalid endpoint.
1175          *
1176          * Reentrant:
1177          *  No.
1178          *
1179          *******************************************************************************/
1180          uint16 USB_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1181                                                                                  CYREENTRANT
1182          {
1183   1          uint8 ri;
1184   1          reg8 *p;
1185   1          #if(USB_EP_MM == USB__EP_MANUAL)
1186   1              uint16 i;
1187   1          #endif /*  USB_EP_MM == USB__EP_MANUAL */
1188   1          #if(USB_EP_MM != USB__EP_DMAAUTO)
1189   1              uint16 xferCount;
1190   1          #endif /*  USB_EP_MM != USB__EP_DMAAUTO */
1191   1      
1192   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP) && (pData != NULL))
1193   1          {
1194   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
1195   2              p = (reg8 *)(USB_ARB_RW1_DR_IND + ri);
1196   2      
1197   2              #if(USB_EP_MM != USB__EP_DMAAUTO)
1198   2                  /* Determine which is smaller the requested data or the available data */
1199   2                  xferCount = USB_GetEPCount(epNumber);
1200   2                  if (length > xferCount)
1201   2                  {
1202   3                      length = xferCount;
1203   3                  }
1204   2              #endif /*  USB_EP_MM != USB__EP_DMAAUTO */
1205   2      
1206   2              #if(USB_EP_MM == USB__EP_MANUAL)
1207   2                  /* Copy the data using the arbiter data register */
1208   2                  for (i = 0u; i < length; i++)
1209   2                  {
1210   3                      pData[i] = CY_GET_REG8(p);
1211   3                  }
1212   2      
1213   2                  /* (re)arming of OUT endpoint */
1214   2                  USB_EnableOutEP(epNumber);
1215   2              #else
                          /*Init DMA if it was not initialized */
                          if(USB_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USB_InitEP_DMA(epNumber, pData);
                          }
              
                      #endif /*  USB_EP_MM == USB__EP_MANUAL */
1223   2      
1224   2              #if(USB_EP_MM == USB__EP_DMAMANUAL)
                          /* Enable DMA in mode2 for transferring data */
                          (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 21  

                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
              
                          /* Generate DMA request */
                          * (reg8 *)(USB_ARB_EP1_CFG_IND + ri) |= USB_ARB_EPX_CFG_DMA_REQ;
                          * (reg8 *)(USB_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USB_ARB_EPX_CFG_DMA_REQ));
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USB_EP_MM == USB__EP_DMAMANUAL */
1239   2      
1240   2              #if(USB_EP_MM == USB__EP_DMAAUTO)
                          /* Enable DMA in mode3 for transferring data */
                          (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length, USB_DmaTd[epNumber],
                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USB_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
              
                          /* Clear Any potential pending DMA requests before starting the DMA channel to transfer data *
             -/
                          (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USB_EP_MM == USB__EP_DMAAUTO */
1254   2      
1255   2          }
1256   1          else
1257   1          {
1258   2              length = 0u;
1259   2          }
1260   1      
1261   1          return(length);
1262   1      }
1263          
1264          
1265          /*******************************************************************************
1266          * Function Name: USB_EnableOutEP
1267          ********************************************************************************
1268          *
1269          * Summary:
1270          *  This function enables an OUT endpoint.  It should not be
1271          *  called for an IN endpoint.
1272          *
1273          * Parameters:
1274          *  epNumber: Endpoint Number
1275          *            Valid values are between 1 and 8.
1276          *
1277          * Return:
1278          *   None.
1279          *
1280          * Global variables:
1281          *  USB_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
1282          *
1283          * Reentrant:
1284          *  No.
1285          *
1286          *******************************************************************************/
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 22  

1287          void USB_EnableOutEP(uint8 epNumber) CYREENTRANT
1288          {
1289   1          uint8 ri;
1290   1      
1291   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
1292   1          {
1293   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
1294   2              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
1295   2              /* Write the Mode register */
1296   2              CY_SET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri), USB_EP[epNumber].epMode);
1297   2          }
1298   1      }
1299          
1300          
1301          /*******************************************************************************
1302          * Function Name: USB_DisableOutEP
1303          ********************************************************************************
1304          *
1305          * Summary:
1306          *  This function disables an OUT endpoint.  It should not be
1307          *  called for an IN endpoint.
1308          *
1309          * Parameters:
1310          *  epNumber: Endpoint Number
1311          *            Valid values are between 1 and 8.
1312          *
1313          * Return:
1314          *  None.
1315          *
1316          *******************************************************************************/
1317          void USB_DisableOutEP(uint8 epNumber) 
1318          {
1319   1          uint8 ri ;
1320   1      
1321   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
1322   1          {
1323   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
1324   2              /* Write the Mode register */
1325   2              CY_SET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri), USB_MODE_NAK_OUT);
1326   2          }
1327   1      }
1328          
1329          
1330          /*******************************************************************************
1331          * Function Name: USB_Force
1332          ********************************************************************************
1333          *
1334          * Summary:
1335          *  Forces the bus state
1336          *
1337          * Parameters:
1338          *  bState
1339          *    USB_FORCE_J
1340          *    USB_FORCE_K
1341          *    USB_FORCE_SE0
1342          *    USB_FORCE_NONE
1343          *
1344          * Return:
1345          *  None.
1346          *
1347          *******************************************************************************/
1348          void USB_Force(uint8 bState) 
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 23  

1349          {
1350   1          CY_SET_REG8(USB_USBIO_CR0_PTR, bState);
1351   1      }
1352          
1353          
1354          /*******************************************************************************
1355          * Function Name: USB_GetEPAckState
1356          ********************************************************************************
1357          *
1358          * Summary:
1359          *  Returns the ACK of the CR0 Register (ACKD)
1360          *
1361          * Parameters:
1362          *  epNumber: Endpoint Number
1363          *            Valid values are between 1 and 8.
1364          *
1365          * Returns
1366          *  0 if nothing has been ACKD, non-=zero something has been ACKD
1367          *
1368          *******************************************************************************/
1369          uint8 USB_GetEPAckState(uint8 epNumber) CYREENTRANT
1370          {
1371   1          uint8 ri;
1372   1          uint8 cr = 0u;
1373   1      
1374   1          if((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
1375   1          {
1376   2              ri = ((epNumber - USB_EP1) << USB_EPX_CNTX_ADDR_SHIFT);
1377   2              cr = CY_GET_REG8((reg8 *)(USB_SIE_EP1_CR0_IND + ri)) & USB_MODE_ACKD;
1378   2          }
1379   1      
1380   1          return(cr);
1381   1      }
1382          
1383          
1384          /*******************************************************************************
1385          * Function Name: USB_SetPowerStatus
1386          ********************************************************************************
1387          *
1388          * Summary:
1389          *  Sets the device power status for reporting in the Get Device Status
1390          *  request
1391          *
1392          * Parameters:
1393          *  powerStatus: USB_DEVICE_STATUS_BUS_POWERED(0) - Bus Powered,
1394          *               USB_DEVICE_STATUS_SELF_POWERED(1) - Self Powered
1395          *
1396          * Return:
1397          *   None.
1398          *
1399          * Global variables:
1400          *  USB_deviceStatus - set power status
1401          *
1402          * Reentrant:
1403          *  No.
1404          *
1405          *******************************************************************************/
1406          void USB_SetPowerStatus(uint8 powerStatus) 
1407          {
1408   1          if (powerStatus != USB_DEVICE_STATUS_BUS_POWERED)
1409   1          {
1410   2              USB_deviceStatus |=  USB_DEVICE_STATUS_SELF_POWERED;
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 24  

1411   2          }
1412   1          else
1413   1          {
1414   2              USB_deviceStatus &=  ((uint8)(~USB_DEVICE_STATUS_SELF_POWERED));
1415   2          }
1416   1      }
1417          
1418          
1419          #if (USB_MON_VBUS == 1u)
              
                  /*******************************************************************************
                  * Function Name: USB_VBusPresent
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determines VBUS presence for Self Powered Devices.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  1 if VBUS is present, otherwise 0.
                  *
                  *******************************************************************************/
                  uint8 USB_VBusPresent(void) 
                  {
                      return((0u != (CY_GET_REG8(USB_VBUS_PS_PTR) & USB_VBUS_MASK)) ? 1u : 0u);
                  }
              
              #endif /* USB_MON_VBUS */
1441          
1442          
1443          /*******************************************************************************
1444          * Function Name: USB_RWUEnabled
1445          ********************************************************************************
1446          *
1447          * Summary:
1448          *  Returns TRUE if Remote Wake Up is enabled, otherwise FALSE
1449          *
1450          * Parameters:
1451          *   None.
1452          *
1453          * Return:
1454          *  TRUE -  Remote Wake Up Enabled
1455          *  FALSE - Remote Wake Up Disabled
1456          *
1457          * Global variables:
1458          *  USB_deviceStatus - checked to determine remote status
1459          *
1460          *******************************************************************************/
1461          uint8 USB_RWUEnabled(void) 
1462          {
1463   1          uint8 result = USB_FALSE;
1464   1          if((USB_deviceStatus & USB_DEVICE_STATUS_REMOTE_WAKEUP) != 0u)
1465   1          {
1466   2              result = USB_TRUE;
1467   2          }
1468   1      
1469   1          return(result);
1470   1      }
1471          
1472          
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 25  

1473          /* [] END OF FILE */
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 26  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USB_Start (BEGIN)
                                           ; SOURCE LINE # 129
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 132
000A 900000      R     MOV     DPTR,#USB_initVar
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0012 120000      R     LCALL   USB_Init
                                           ; SOURCE LINE # 135
0015 900000      R     MOV     DPTR,#USB_initVar
0018 7401              MOV     A,#01H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
001B         ?C0001:
                                           ; SOURCE LINE # 137
001B 900000      R     MOV     DPTR,#device
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#mode
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 120000      R     LCALL   _USB_InitComponent
                                           ; SOURCE LINE # 138
0028 22                RET     
             ; FUNCTION _USB_Start (END)

             ; FUNCTION USB_Init (BEGIN)
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 165
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 168
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 170
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4401              ORL     A,#01H
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 27  

001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 173
001E 90609D            MOV     DPTR,#0609DH
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 175
0024 906009            MOV     DPTR,#06009H
0027 7402              MOV     A,#02H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
002A 906010            MOV     DPTR,#06010H
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 547F              ANL     A,#07FH
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
0035 7F00              MOV     R7,#00H
0037 7E00              MOV     R6,#00H
0039 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 185
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 54F9              ANL     A,#0F9H
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 189
0047 906012            MOV     DPTR,#06012H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 54DF              ANL     A,#0DFH
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
0052 904394            MOV     DPTR,#04394H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 4401              ORL     A,#01H
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
005D 7F01              MOV     R7,#01H
005F 7E00              MOV     R6,#00H
0061 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 196
0064 7F28              MOV     R7,#028H
0066 7E00              MOV     R6,#00H
0068 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 198
006B 9051F8            MOV     DPTR,#051F8H
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 28  

006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 547F              ANL     A,#07FH
0073 FF                MOV     R7,A
0074 EF                MOV     A,R7
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0076 9051F8            MOV     DPTR,#051F8H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54BF              ANL     A,#0BFH
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
0081 904394            MOV     DPTR,#04394H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 4402              ORL     A,#02H
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
008C 7F02              MOV     R7,#02H
008E 7E00              MOV     R6,#00H
0090 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 205
0093 904394            MOV     DPTR,#04394H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 4404              ORL     A,#04H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
009E 906084            MOV     DPTR,#06084H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
00A3 906085            MOV     DPTR,#06085H
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
00A8 900000      R     MOV     DPTR,#enableInterrupts
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 226
00B0 7C00        E     MOV     R4,#HIGH USB_BUS_RESET_ISR
00B2 7D00        E     MOV     R5,#LOW USB_BUS_RESET_ISR
00B4 7F17              MOV     R7,#017H
00B6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 227
00B9 7D07              MOV     R5,#07H
00BB 7F17              MOV     R7,#017H
00BD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 231
00C0 7C00        E     MOV     R4,#HIGH USB_SOF_ISR
00C2 7D00        E     MOV     R5,#LOW USB_SOF_ISR
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 29  

00C4 7F15              MOV     R7,#015H
00C6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 232
00C9 7D07              MOV     R5,#07H
00CB 7F15              MOV     R7,#015H
00CD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 236
00D0 7C00        E     MOV     R4,#HIGH USB_EP_0_ISR
00D2 7D00        E     MOV     R5,#LOW USB_EP_0_ISR
00D4 7F18              MOV     R7,#018H
00D6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 237
00D9 7D07              MOV     R5,#07H
00DB 7F18              MOV     R7,#018H
00DD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 241
00E0 7C00        E     MOV     R4,#HIGH USB_EP_1_ISR
00E2 7D00        E     MOV     R5,#LOW USB_EP_1_ISR
00E4 7F05              MOV     R7,#05H
00E6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 242
00E9 7D07              MOV     R5,#07H
00EB 7F05              MOV     R7,#05H
00ED 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 247
00F0 7C00        E     MOV     R4,#HIGH USB_EP_2_ISR
00F2 7D00        E     MOV     R5,#LOW USB_EP_2_ISR
00F4 7F06              MOV     R7,#06H
00F6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 248
00F9 7D07              MOV     R5,#07H
00FB 7F06              MOV     R7,#06H
00FD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 293
0100 22                RET     
             ; FUNCTION USB_Init (END)

             ; FUNCTION _USB_InitComponent (BEGIN)
                                           ; SOURCE LINE # 348
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 349
                                           ; SOURCE LINE # 364
000A 9044C2            MOV     DPTR,#044C2H
000D 7480              MOV     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
0010 9044C3            MOV     DPTR,#044C3H
0013 7401              MOV     A,#01H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 367
0016 9044C0            MOV     DPTR,#044C0H
0019 7420              MOV     A,#020H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 370
001C 9044C0            MOV     DPTR,#044C0H
001F 7440              MOV     A,#040H
0021 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 30  

                                           ; SOURCE LINE # 413
0022 900000      E     MOV     DPTR,#USB_transferState
0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 416
0027 900000      R     MOV     DPTR,#mode
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 120000      E     LCALL   ?C?CCASE
0030 0000        R     DW      ?C0005
0032 00                DB      00H
0033 0000        R     DW      ?C0006
0035 01                DB      01H
0036 0000              DW      00H
0038 0000        R     DW      ?C0007
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
003A         ?C0005:
                                           ; SOURCE LINE # 419
003A 906009            MOV     DPTR,#06009H
003D 7402              MOV     A,#02H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 420
0040 800E              SJMP    ?C0004
                                           ; SOURCE LINE # 421
0042         ?C0006:
                                           ; SOURCE LINE # 422
0042 906009            MOV     DPTR,#06009H
0045 7403              MOV     A,#03H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 423
0048 8006              SJMP    ?C0004
                                           ; SOURCE LINE # 424
004A         ?C0007:
                                           ; SOURCE LINE # 428
004A 906009            MOV     DPTR,#06009H
004D 7403              MOV     A,#03H
004F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0050         ?C0004:
                                           ; SOURCE LINE # 434
0050 900000      R     MOV     DPTR,#device
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 900000      E     MOV     DPTR,#USB_device
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
005A 900000      E     MOV     DPTR,#USB_configuration
005D E4                CLR     A
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
005F 900000      E     MOV     DPTR,#USB_interfaceNumber
0062 E4                CLR     A
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
0064 900000      E     MOV     DPTR,#USB_configurationChanged
0067 E4                CLR     A
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 31  

0069 900000      E     MOV     DPTR,#USB_deviceAddress
006C E4                CLR     A
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
006E 900000      E     MOV     DPTR,#USB_deviceStatus
0071 E4                CLR     A
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
0073 900000      E     MOV     DPTR,#USB_lastPacketSize
0076 E4                CLR     A
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 446
0078 906028            MOV     DPTR,#06028H
007B 7403              MOV     A,#03H
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
007E 906008            MOV     DPTR,#06008H
0081 7480              MOV     A,#080H
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
0084 7F01              MOV     R7,#01H
0086 7E00              MOV     R6,#00H
0088 7D00              MOV     R5,#00H
008A 7C00              MOV     R4,#00H
008C 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 455
008F 906012            MOV     DPTR,#06012H
0092 7404              MOV     A,#04H
0094 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 456
0095 22                RET     
             ; FUNCTION _USB_InitComponent (END)

             ; FUNCTION USB_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 512
0000 900000      E     MOV     DPTR,#USB_transferState
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
0005 900000      E     MOV     DPTR,#USB_configuration
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 516
000A 900000      E     MOV     DPTR,#USB_interfaceNumber
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
000F 900000      E     MOV     DPTR,#USB_configurationChanged
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
0014 900000      E     MOV     DPTR,#USB_deviceAddress
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
0019 900000      E     MOV     DPTR,#USB_deviceStatus
001C E4                CLR     A
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 521
001E 900000      E     MOV     DPTR,#USB_lastPacketSize
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 32  

0021 E4                CLR     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 525
0023 906028            MOV     DPTR,#06028H
0026 7403              MOV     A,#03H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 528
0029 906008            MOV     DPTR,#06008H
002C 7480              MOV     A,#080H
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 530
002F 22                RET     
             ; FUNCTION USB_ReInitComponent (END)

             ; FUNCTION USB_Stop (BEGIN)
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 572
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
000B 906012            MOV     DPTR,#06012H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 54FB              ANL     A,#0FBH
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
0016 9043A5            MOV     DPTR,#043A5H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54FE              ANL     A,#0FEH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
0021 9043B5            MOV     DPTR,#043B5H
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 54FE              ANL     A,#0FEH
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 581
002C 9044CA            MOV     DPTR,#044CAH
002F 7480              MOV     A,#080H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
0032 9044CB            MOV     DPTR,#044CBH
0035 7401              MOV     A,#01H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 33  

0038 9044C8            MOV     DPTR,#044C8H
003B 7420              MOV     A,#020H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 587
003E 9044C8            MOV     DPTR,#044C8H
0041 7440              MOV     A,#040H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 609
0044 900000      E     MOV     DPTR,#USB_configuration
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 610
0049 900000      E     MOV     DPTR,#USB_interfaceNumber
004C E4                CLR     A
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
004E 900000      E     MOV     DPTR,#USB_configurationChanged
0051 E4                CLR     A
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 612
0053 900000      E     MOV     DPTR,#USB_deviceAddress
0056 E4                CLR     A
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
0058 900000      E     MOV     DPTR,#USB_deviceStatus
005B E4                CLR     A
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 614
005D 900000      R     MOV     DPTR,#USB_initVar
0060 E4                CLR     A
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 616
0062 22                RET     
             ; FUNCTION USB_Stop (END)

             ; FUNCTION USB_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 636
                                           ; SOURCE LINE # 639
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#r
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 640
000A 900000      R     MOV     DPTR,#r
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 54FB              ANL     A,#0FBH
0012 FF                MOV     R7,A
0013 906009            MOV     DPTR,#06009H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 642
0018 900000      R     MOV     DPTR,#r
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 5404              ANL     A,#04H
0020 FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 34  

0021 EF                MOV     A,R7
0022 13                RRC     A
0023 13                RRC     A
0024 543F              ANL     A,#03FH
0026 FF                MOV     R7,A
                                           ; SOURCE LINE # 643
0027         ?C0011:
0027 22                RET     
             ; FUNCTION USB_CheckActivity (END)

             ; FUNCTION USB_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 662
0000 900000      E     MOV     DPTR,#USB_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 663
0005         ?C0012:
0005 22                RET     
             ; FUNCTION USB_GetConfiguration (END)

             ; FUNCTION USB_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
                                           ; SOURCE LINE # 688
0000 900000      R     MOV     DPTR,#res
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0005 900000      E     MOV     DPTR,#USB_configurationChanged
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0013
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
000D 900000      E     MOV     DPTR,#USB_configurationChanged
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#res
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 693
0017 900000      E     MOV     DPTR,#USB_configurationChanged
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 694
001C         ?C0013:
                                           ; SOURCE LINE # 696
001C 900000      R     MOV     DPTR,#res
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
                                           ; SOURCE LINE # 697
0021         ?C0014:
0021 22                RET     
             ; FUNCTION USB_IsConfigurationChanged (END)

             ; FUNCTION _USB_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 714
0000 900000      R     MOV     DPTR,#interfaceNumber
0003 EF                MOV     A,R7
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 35  

0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0005 900000      R     MOV     DPTR,#interfaceNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7400        E     MOV     A,#LOW USB_interfaceSetting
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        E     ADDC    A,#HIGH USB_interfaceSetting
0012 F583              MOV     DPH,A
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 718
0016         ?C0015:
0016 22                RET     
             ; FUNCTION _USB_GetInterfaceSetting (END)

             ; FUNCTION _?USB_GetEPState (BEGIN)
                                           ; SOURCE LINE # 735
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 737
0008 850083      E     MOV     DPH,?C_XBP
000B 850082      E     MOV     DPL,?C_XBP+01H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 75F00B            MOV     B,#0BH
0014 A4                MUL     AB
0015 2400        E     ADD     A,#LOW USB_EP+01H
0017 F582              MOV     DPL,A
0019 E4                CLR     A
001A 3400        E     ADDC    A,#HIGH USB_EP+01H
001C F583              MOV     DPH,A
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 738
0020         ?C0016:
0020 900001            MOV     DPTR,#01H
0023 120000      E     LCALL   ?C?ADDXBP
0026 22                RET     
             ; FUNCTION _?USB_GetEPState (END)

             ; FUNCTION _?USB_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 760
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 90FFFD            MOV     DPTR,#0FFFDH
000B 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 763
000E 850083      E     MOV     DPH,?C_XBP
0011 850082      E     MOV     DPL,?C_XBP+01H
0014 A3                INC     DPTR
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 36  

0018 E4                CLR     A
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
001A 900003            MOV     DPTR,#03H
001D 120000      E     LCALL   ?C?XBPOFF
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 D3                SETB    C
0024 9400              SUBB    A,#00H
0026 5003              JNC     $ + 5H
0028 020000      R     LJMP    ?C0017
002B 900003            MOV     DPTR,#03H
002E 120000      E     LCALL   ?C?XBPOFF
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 C3                CLR     C
0035 9409              SUBB    A,#09H
0037 4003              JC      $ + 5H
0039 020000      R     LJMP    ?C0017
                                           ; SOURCE LINE # 766
                                           ; SOURCE LINE # 767
003C 900003            MOV     DPTR,#03H
003F 120000      E     LCALL   ?C?XBPOFF
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 7E00              MOV     R6,#00H
0046 EF                MOV     A,R7
0047 24FF              ADD     A,#0FFH
0049 FF                MOV     R7,A
004A EE                MOV     A,R6
004B 34FF              ADDC    A,#0FFH
004D FE                MOV     R6,A
004E EF                MOV     A,R7
004F C4                SWAP    A
0050 F8                MOV     R0,A
0051 540F              ANL     A,#0FH
0053 C8                XCH     A,R0
0054 68                XRL     A,R0
0055 FF                MOV     R7,A
0056 EE                MOV     A,R6
0057 C4                SWAP    A
0058 54F0              ANL     A,#0F0H
005A 48                ORL     A,R0
005B FE                MOV     R6,A
005C 850083      E     MOV     DPH,?C_XBP
005F 850082      E     MOV     DPL,?C_XBP+01H
0062 EF                MOV     A,R7
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 769
0064 850083      E     MOV     DPH,?C_XBP
0067 850082      E     MOV     DPL,?C_XBP+01H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C 7E00              MOV     R6,#00H
006E EF                MOV     A,R7
006F 240C              ADD     A,#0CH
0071 FF                MOV     R7,A
0072 EE                MOV     A,R6
0073 3460              ADDC    A,#060H
0075 FE                MOV     R6,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 37  

0076 8F82              MOV     DPL,R7
0078 8E83              MOV     DPH,R6
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C EF                MOV     A,R7
007D 540F              ANL     A,#0FH
007F FF                MOV     R7,A
0080 7E00              MOV     R6,#00H
0082 850083      E     MOV     DPH,?C_XBP
0085 850082      E     MOV     DPL,?C_XBP+01H
0088 A3                INC     DPTR
0089 EE                MOV     A,R6
008A F0                MOVX    @DPTR,A
008B A3                INC     DPTR
008C EF                MOV     A,R7
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
008E 850083      E     MOV     DPH,?C_XBP
0091 850082      E     MOV     DPL,?C_XBP+01H
0094 E0                MOVX    A,@DPTR
0095 FF                MOV     R7,A
0096 7E00              MOV     R6,#00H
0098 EF                MOV     A,R7
0099 240D              ADD     A,#0DH
009B FF                MOV     R7,A
009C EE                MOV     A,R6
009D 3460              ADDC    A,#060H
009F FE                MOV     R6,A
00A0 8F82              MOV     DPL,R7
00A2 8E83              MOV     DPH,R6
00A4 E0                MOVX    A,@DPTR
00A5 FF                MOV     R7,A
00A6 EF                MOV     A,R7
00A7 FD                MOV     R5,A
00A8 7C00              MOV     R4,#00H
00AA 850083      E     MOV     DPH,?C_XBP
00AD 850082      E     MOV     DPL,?C_XBP+01H
00B0 A3                INC     DPTR
00B1 E0                MOVX    A,@DPTR
00B2 FE                MOV     R6,A
00B3 A3                INC     DPTR
00B4 E0                MOVX    A,@DPTR
00B5 FF                MOV     R7,A
00B6 EF                MOV     A,R7
00B7 7F00              MOV     R7,#00H
00B9 FE                MOV     R6,A
00BA EE                MOV     A,R6
00BB 4C                ORL     A,R4
00BC FE                MOV     R6,A
00BD EF                MOV     A,R7
00BE 4D                ORL     A,R5
00BF FF                MOV     R7,A
00C0 850083      E     MOV     DPH,?C_XBP
00C3 850082      E     MOV     DPL,?C_XBP+01H
00C6 A3                INC     DPTR
00C7 EE                MOV     A,R6
00C8 F0                MOVX    @DPTR,A
00C9 A3                INC     DPTR
00CA EF                MOV     A,R7
00CB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 772
00CC 850083      E     MOV     DPH,?C_XBP
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 38  

00CF 850082      E     MOV     DPL,?C_XBP+01H
00D2 A3                INC     DPTR
00D3 74FF              MOV     A,#0FFH
00D5 75F0FE            MOV     B,#0FEH
00D8 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 773
00DB         ?C0017:
                                           ; SOURCE LINE # 774
00DB 850083      E     MOV     DPH,?C_XBP
00DE 850082      E     MOV     DPL,?C_XBP+01H
00E1 A3                INC     DPTR
00E2 E0                MOVX    A,@DPTR
00E3 FE                MOV     R6,A
00E4 A3                INC     DPTR
00E5 E0                MOVX    A,@DPTR
00E6 FF                MOV     R7,A
                                           ; SOURCE LINE # 775
00E7         ?C0018:
00E7 900004            MOV     DPTR,#04H
00EA 120000      E     LCALL   ?C?ADDXBP
00ED 22                RET     
             ; FUNCTION _?USB_GetEPCount (END)

             ; FUNCTION _?USB_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1009
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?PSTXDATA
0009 90FFFF            MOV     DPTR,#0FFFFH
000C 120000      E     LCALL   ?C?ADDXBP
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
0011 90FFFB            MOV     DPTR,#0FFFBH
0014 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1010
                                           ; SOURCE LINE # 1018
0017 900005            MOV     DPTR,#05H
001A 120000      E     LCALL   ?C?XBPOFF
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 D3                SETB    C
0021 9400              SUBB    A,#00H
0023 5003              JNC     $ + 5H
0025 020000      R     LJMP    ?C0025
0028 900005            MOV     DPTR,#05H
002B 120000      E     LCALL   ?C?XBPOFF
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 C3                CLR     C
0032 9409              SUBB    A,#09H
0034 4003              JC      $ + 5H
0036 020000      R     LJMP    ?C0025
                                           ; SOURCE LINE # 1019
                                           ; SOURCE LINE # 1020
0039 900005            MOV     DPTR,#05H
003C 120000      E     LCALL   ?C?XBPOFF
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 EF                MOV     A,R7
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 39  

0044 24FF              ADD     A,#0FFH
0046 FF                MOV     R7,A
0047 EE                MOV     A,R6
0048 34FF              ADDC    A,#0FFH
004A FE                MOV     R6,A
004B EF                MOV     A,R7
004C C4                SWAP    A
004D F8                MOV     R0,A
004E 540F              ANL     A,#0FH
0050 C8                XCH     A,R0
0051 68                XRL     A,R0
0052 FF                MOV     R7,A
0053 EE                MOV     A,R6
0054 C4                SWAP    A
0055 54F0              ANL     A,#0F0H
0057 48                ORL     A,R0
0058 FE                MOV     R6,A
0059 850083      E     MOV     DPH,?C_XBP
005C 850082      E     MOV     DPL,?C_XBP+01H
005F EF                MOV     A,R7
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1021
0061 850083      E     MOV     DPH,?C_XBP
0064 850082      E     MOV     DPL,?C_XBP+01H
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 7E00              MOV     R6,#00H
006B EF                MOV     A,R7
006C 2488              ADD     A,#088H
006E FF                MOV     R7,A
006F EE                MOV     A,R6
0070 3460              ADDC    A,#060H
0072 FE                MOV     R6,A
0073 850083      E     MOV     DPH,?C_XBP
0076 850082      E     MOV     DPL,?C_XBP+01H
0079 A3                INC     DPTR
007A EE                MOV     A,R6
007B F0                MOVX    @DPTR,A
007C A3                INC     DPTR
007D EF                MOV     A,R7
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1025
007F 900005            MOV     DPTR,#05H
0082 120000      E     LCALL   ?C?XBPOFF
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 75F00B            MOV     B,#0BH
008B A4                MUL     AB
008C 2400        E     ADD     A,#LOW USB_EP+06H
008E F582              MOV     DPL,A
0090 E4                CLR     A
0091 3400        E     ADDC    A,#HIGH USB_EP+06H
0093 F583              MOV     DPH,A
0095 E0                MOVX    A,@DPTR
0096 FE                MOV     R6,A
0097 A3                INC     DPTR
0098 E0                MOVX    A,@DPTR
0099 FF                MOV     R7,A
009A C3                CLR     C
009B E4                CLR     A
009C 9F                SUBB    A,R7
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 40  

009D FF                MOV     R7,A
009E 7402              MOV     A,#02H
00A0 9E                SUBB    A,R6
00A1 FE                MOV     R6,A
00A2 900009            MOV     DPTR,#09H
00A5 120000      E     LCALL   ?C?XBPOFF
00A8 E0                MOVX    A,@DPTR
00A9 FC                MOV     R4,A
00AA A3                INC     DPTR
00AB E0                MOVX    A,@DPTR
00AC FD                MOV     R5,A
00AD D3                SETB    C
00AE ED                MOV     A,R5
00AF 9F                SUBB    A,R7
00B0 EC                MOV     A,R4
00B1 9E                SUBB    A,R6
00B2 402E              JC      ?C0020
                                           ; SOURCE LINE # 1026
                                           ; SOURCE LINE # 1027
00B4 900005            MOV     DPTR,#05H
00B7 120000      E     LCALL   ?C?XBPOFF
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC EF                MOV     A,R7
00BD 75F00B            MOV     B,#0BH
00C0 A4                MUL     AB
00C1 2400        E     ADD     A,#LOW USB_EP+06H
00C3 F582              MOV     DPL,A
00C5 E4                CLR     A
00C6 3400        E     ADDC    A,#HIGH USB_EP+06H
00C8 F583              MOV     DPH,A
00CA E0                MOVX    A,@DPTR
00CB FE                MOV     R6,A
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE FF                MOV     R7,A
00CF C3                CLR     C
00D0 E4                CLR     A
00D1 9F                SUBB    A,R7
00D2 FF                MOV     R7,A
00D3 7402              MOV     A,#02H
00D5 9E                SUBB    A,R6
00D6 FE                MOV     R6,A
00D7 900009            MOV     DPTR,#09H
00DA 120000      E     LCALL   ?C?XBPOFF
00DD EE                MOV     A,R6
00DE F0                MOVX    @DPTR,A
00DF A3                INC     DPTR
00E0 EF                MOV     A,R7
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1028
00E2         ?C0020:
                                           ; SOURCE LINE # 1033
00E2 900009            MOV     DPTR,#09H
00E5 120000      E     LCALL   ?C?XBPOFF
00E8 E0                MOVX    A,@DPTR
00E9 FE                MOV     R6,A
00EA A3                INC     DPTR
00EB E0                MOVX    A,@DPTR
00EC FF                MOV     R7,A
00ED EE                MOV     A,R6
00EE FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 41  

00EF 7E00              MOV     R6,#00H
00F1 900005            MOV     DPTR,#05H
00F4 120000      E     LCALL   ?C?XBPOFF
00F7 E0                MOVX    A,@DPTR
00F8 FE                MOV     R6,A
00F9 EE                MOV     A,R6
00FA 75F00B            MOV     B,#0BH
00FD A4                MUL     AB
00FE 2400        E     ADD     A,#LOW USB_EP+03H
0100 F582              MOV     DPL,A
0102 E4                CLR     A
0103 3400        E     ADDC    A,#HIGH USB_EP+03H
0105 F583              MOV     DPH,A
0107 E0                MOVX    A,@DPTR
0108 FE                MOV     R6,A
0109 EF                MOV     A,R7
010A 4E                ORL     A,R6
010B FF                MOV     R7,A
010C 850083      E     MOV     DPH,?C_XBP
010F 850082      E     MOV     DPL,?C_XBP+01H
0112 E0                MOVX    A,@DPTR
0113 FE                MOV     R6,A
0114 EE                MOV     A,R6
0115 FD                MOV     R5,A
0116 7C00              MOV     R4,#00H
0118 ED                MOV     A,R5
0119 240C              ADD     A,#0CH
011B FD                MOV     R5,A
011C EC                MOV     A,R4
011D 3460              ADDC    A,#060H
011F FC                MOV     R4,A
0120 8D82              MOV     DPL,R5
0122 8C83              MOV     DPH,R4
0124 EF                MOV     A,R7
0125 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1034
0126 900009            MOV     DPTR,#09H
0129 120000      E     LCALL   ?C?XBPOFF
012C E0                MOVX    A,@DPTR
012D FE                MOV     R6,A
012E A3                INC     DPTR
012F E0                MOVX    A,@DPTR
0130 FF                MOV     R7,A
0131 EF                MOV     A,R7
0132 54FF              ANL     A,#0FFH
0134 FF                MOV     R7,A
0135 850083      E     MOV     DPH,?C_XBP
0138 850082      E     MOV     DPL,?C_XBP+01H
013B E0                MOVX    A,@DPTR
013C FE                MOV     R6,A
013D EE                MOV     A,R6
013E FD                MOV     R5,A
013F 7C00              MOV     R4,#00H
0141 ED                MOV     A,R5
0142 240D              ADD     A,#0DH
0144 FD                MOV     R5,A
0145 EC                MOV     A,R4
0146 3460              ADDC    A,#060H
0148 FC                MOV     R4,A
0149 8D82              MOV     DPL,R5
014B 8C83              MOV     DPH,R4
014D EF                MOV     A,R7
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 42  

014E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1037
014F 7B00              MOV     R3,#00H
0151 7A00              MOV     R2,#00H
0153 7900              MOV     R1,#00H
0155 C003              PUSH    AR3
0157 C002              PUSH    AR2
0159 C001              PUSH    AR1
015B 900006            MOV     DPTR,#06H
015E 120000      E     LCALL   ?C?XBPOFF
0161 120000      E     LCALL   ?C?PLDXDATA
0164 D082              POP     DPL
0166 D083              POP     DPH
0168 D0E0              POP     ACC
016A 6B                XRL     A,R3
016B 7008              JNZ     ?C0045
016D E9                MOV     A,R1
016E 6582              XRL     A,DPL
0170 7003              JNZ     ?C0045
0172 EA                MOV     A,R2
0173 6583              XRL     A,DPH
0175         ?C0045:
0175 6067              JZ      ?C0021
                                           ; SOURCE LINE # 1038
                                           ; SOURCE LINE # 1040
0177 900003            MOV     DPTR,#03H
017A 120000      E     LCALL   ?C?XBPOFF
017D E4                CLR     A
017E F0                MOVX    @DPTR,A
017F A3                INC     DPTR
0180 E4                CLR     A
0181 F0                MOVX    @DPTR,A
0182         ?C0022:
0182 900009            MOV     DPTR,#09H
0185 120000      E     LCALL   ?C?XBPOFF
0188 E0                MOVX    A,@DPTR
0189 FE                MOV     R6,A
018A A3                INC     DPTR
018B E0                MOVX    A,@DPTR
018C FF                MOV     R7,A
018D 900003            MOV     DPTR,#03H
0190 120000      E     LCALL   ?C?XBPOFF
0193 E0                MOVX    A,@DPTR
0194 FC                MOV     R4,A
0195 A3                INC     DPTR
0196 E0                MOVX    A,@DPTR
0197 FD                MOV     R5,A
0198 C3                CLR     C
0199 ED                MOV     A,R5
019A 9F                SUBB    A,R7
019B EC                MOV     A,R4
019C 9E                SUBB    A,R6
019D 503F              JNC     ?C0021
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
019F 900006            MOV     DPTR,#06H
01A2 120000      E     LCALL   ?C?XBPOFF
01A5 120000      E     LCALL   ?C?PLDXDATA
01A8 900003            MOV     DPTR,#03H
01AB 120000      E     LCALL   ?C?XBPOFF
01AE E0                MOVX    A,@DPTR
01AF FE                MOV     R6,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 43  

01B0 A3                INC     DPTR
01B1 E0                MOVX    A,@DPTR
01B2 FF                MOV     R7,A
01B3 E9                MOV     A,R1
01B4 2F                ADD     A,R7
01B5 F9                MOV     R1,A
01B6 EA                MOV     A,R2
01B7 3E                ADDC    A,R6
01B8 FA                MOV     R2,A
01B9 120000      E     LCALL   ?C?CLDPTR
01BC FF                MOV     R7,A
01BD 850083      E     MOV     DPH,?C_XBP
01C0 850082      E     MOV     DPL,?C_XBP+01H
01C3 A3                INC     DPTR
01C4 E0                MOVX    A,@DPTR
01C5 FC                MOV     R4,A
01C6 A3                INC     DPTR
01C7 E0                MOVX    A,@DPTR
01C8 FD                MOV     R5,A
01C9 8D82              MOV     DPL,R5
01CB 8C83              MOV     DPH,R4
01CD EF                MOV     A,R7
01CE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1043
01CF 900003            MOV     DPTR,#03H
01D2 120000      E     LCALL   ?C?XBPOFF
01D5 E4                CLR     A
01D6 75F001            MOV     B,#01H
01D9 120000      E     LCALL   ?C?IILDX
01DC 80A4              SJMP    ?C0022
                                           ; SOURCE LINE # 1044
01DE         ?C0021:
                                           ; SOURCE LINE # 1045
01DE 900005            MOV     DPTR,#05H
01E1 120000      E     LCALL   ?C?XBPOFF
01E4 E0                MOVX    A,@DPTR
01E5 FF                MOV     R7,A
01E6 EF                MOV     A,R7
01E7 75F00B            MOV     B,#0BH
01EA A4                MUL     AB
01EB 2400        E     ADD     A,#LOW USB_EP+01H
01ED F582              MOV     DPL,A
01EF E4                CLR     A
01F0 3400        E     ADDC    A,#HIGH USB_EP+01H
01F2 F583              MOV     DPH,A
01F4 E4                CLR     A
01F5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1047
01F6 900005            MOV     DPTR,#05H
01F9 120000      E     LCALL   ?C?XBPOFF
01FC E0                MOVX    A,@DPTR
01FD FF                MOV     R7,A
01FE EF                MOV     A,R7
01FF 75F00B            MOV     B,#0BH
0202 A4                MUL     AB
0203 2400        E     ADD     A,#LOW USB_EP+05H
0205 F582              MOV     DPL,A
0207 E4                CLR     A
0208 3400        E     ADDC    A,#HIGH USB_EP+05H
020A F583              MOV     DPH,A
020C E0                MOVX    A,@DPTR
020D FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 44  

020E 850083      E     MOV     DPH,?C_XBP
0211 850082      E     MOV     DPL,?C_XBP+01H
0214 E0                MOVX    A,@DPTR
0215 FE                MOV     R6,A
0216 EE                MOV     A,R6
0217 FD                MOV     R5,A
0218 7C00              MOV     R4,#00H
021A ED                MOV     A,R5
021B 240E              ADD     A,#0EH
021D FD                MOV     R5,A
021E EC                MOV     A,R4
021F 3460              ADDC    A,#060H
0221 FC                MOV     R4,A
0222 8D82              MOV     DPL,R5
0224 8C83              MOV     DPH,R4
0226 EF                MOV     A,R7
0227 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1151
                                           ; SOURCE LINE # 1152
0228         ?C0025:
0228 90000B            MOV     DPTR,#0BH
022B 120000      E     LCALL   ?C?ADDXBP
022E 22                RET     
             ; FUNCTION _?USB_LoadInEP (END)

             ; FUNCTION _?USB_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1180
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?PSTXDATA
0009 90FFFF            MOV     DPTR,#0FFFFH
000C 120000      E     LCALL   ?C?ADDXBP
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
0011 90FFF9            MOV     DPTR,#0FFF9H
0014 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1181
                                           ; SOURCE LINE # 1192
0017 900007            MOV     DPTR,#07H
001A 120000      E     LCALL   ?C?XBPOFF
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 D3                SETB    C
0021 9400              SUBB    A,#00H
0023 5003              JNC     $ + 5H
0025 020000      R     LJMP    ?C0026
0028 900007            MOV     DPTR,#07H
002B 120000      E     LCALL   ?C?XBPOFF
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 C3                CLR     C
0032 9409              SUBB    A,#09H
0034 4003              JC      $ + 5H
0036 020000      R     LJMP    ?C0026
0039 7B00              MOV     R3,#00H
003B 7A00              MOV     R2,#00H
003D 7900              MOV     R1,#00H
003F C003              PUSH    AR3
0041 C002              PUSH    AR2
0043 C001              PUSH    AR1
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 45  

0045 900008            MOV     DPTR,#08H
0048 120000      E     LCALL   ?C?XBPOFF
004B 120000      E     LCALL   ?C?PLDXDATA
004E D082              POP     DPL
0050 D083              POP     DPH
0052 D0E0              POP     ACC
0054 6B                XRL     A,R3
0055 7008              JNZ     ?C0046
0057 E9                MOV     A,R1
0058 6582              XRL     A,DPL
005A 7003              JNZ     ?C0046
005C EA                MOV     A,R2
005D 6583              XRL     A,DPH
005F         ?C0046:
005F 7003              JNZ     $ + 5H
0061 020000      R     LJMP    ?C0026
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
0064 900007            MOV     DPTR,#07H
0067 120000      E     LCALL   ?C?XBPOFF
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C 7E00              MOV     R6,#00H
006E EF                MOV     A,R7
006F 24FF              ADD     A,#0FFH
0071 FF                MOV     R7,A
0072 EE                MOV     A,R6
0073 34FF              ADDC    A,#0FFH
0075 FE                MOV     R6,A
0076 EF                MOV     A,R7
0077 C4                SWAP    A
0078 F8                MOV     R0,A
0079 540F              ANL     A,#0FH
007B C8                XCH     A,R0
007C 68                XRL     A,R0
007D FF                MOV     R7,A
007E EE                MOV     A,R6
007F C4                SWAP    A
0080 54F0              ANL     A,#0F0H
0082 48                ORL     A,R0
0083 FE                MOV     R6,A
0084 850083      E     MOV     DPH,?C_XBP
0087 850082      E     MOV     DPL,?C_XBP+01H
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1195
008C 850083      E     MOV     DPH,?C_XBP
008F 850082      E     MOV     DPL,?C_XBP+01H
0092 E0                MOVX    A,@DPTR
0093 FF                MOV     R7,A
0094 7E00              MOV     R6,#00H
0096 EF                MOV     A,R7
0097 2488              ADD     A,#088H
0099 FF                MOV     R7,A
009A EE                MOV     A,R6
009B 3460              ADDC    A,#060H
009D FE                MOV     R6,A
009E 850083      E     MOV     DPH,?C_XBP
00A1 850082      E     MOV     DPL,?C_XBP+01H
00A4 A3                INC     DPTR
00A5 EE                MOV     A,R6
00A6 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 46  

00A7 A3                INC     DPTR
00A8 EF                MOV     A,R7
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1199
00AA 900007            MOV     DPTR,#07H
00AD 120000      E     LCALL   ?C?XBPOFF
00B0 E0                MOVX    A,@DPTR
00B1 FF                MOV     R7,A
00B2 120000      R     LCALL   _?USB_GetEPCount
00B5 900005            MOV     DPTR,#05H
00B8 120000      E     LCALL   ?C?XBPOFF
00BB EE                MOV     A,R6
00BC F0                MOVX    @DPTR,A
00BD A3                INC     DPTR
00BE EF                MOV     A,R7
00BF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1200
00C0 900005            MOV     DPTR,#05H
00C3 120000      E     LCALL   ?C?XBPOFF
00C6 E0                MOVX    A,@DPTR
00C7 FE                MOV     R6,A
00C8 A3                INC     DPTR
00C9 E0                MOVX    A,@DPTR
00CA FF                MOV     R7,A
00CB 90000B            MOV     DPTR,#0BH
00CE 120000      E     LCALL   ?C?XBPOFF
00D1 E0                MOVX    A,@DPTR
00D2 FC                MOV     R4,A
00D3 A3                INC     DPTR
00D4 E0                MOVX    A,@DPTR
00D5 FD                MOV     R5,A
00D6 D3                SETB    C
00D7 ED                MOV     A,R5
00D8 9F                SUBB    A,R7
00D9 EC                MOV     A,R4
00DA 9E                SUBB    A,R6
00DB 4016              JC      ?C0027
                                           ; SOURCE LINE # 1201
                                           ; SOURCE LINE # 1202
00DD 900005            MOV     DPTR,#05H
00E0 120000      E     LCALL   ?C?XBPOFF
00E3 E0                MOVX    A,@DPTR
00E4 FE                MOV     R6,A
00E5 A3                INC     DPTR
00E6 E0                MOVX    A,@DPTR
00E7 FF                MOV     R7,A
00E8 90000B            MOV     DPTR,#0BH
00EB 120000      E     LCALL   ?C?XBPOFF
00EE EE                MOV     A,R6
00EF F0                MOVX    @DPTR,A
00F0 A3                INC     DPTR
00F1 EF                MOV     A,R7
00F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1203
00F3         ?C0027:
                                           ; SOURCE LINE # 1208
00F3 900003            MOV     DPTR,#03H
00F6 120000      E     LCALL   ?C?XBPOFF
00F9 E4                CLR     A
00FA F0                MOVX    @DPTR,A
00FB A3                INC     DPTR
00FC E4                CLR     A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 47  

00FD F0                MOVX    @DPTR,A
00FE         ?C0028:
00FE 90000B            MOV     DPTR,#0BH
0101 120000      E     LCALL   ?C?XBPOFF
0104 E0                MOVX    A,@DPTR
0105 FE                MOV     R6,A
0106 A3                INC     DPTR
0107 E0                MOVX    A,@DPTR
0108 FF                MOV     R7,A
0109 900003            MOV     DPTR,#03H
010C 120000      E     LCALL   ?C?XBPOFF
010F E0                MOVX    A,@DPTR
0110 FC                MOV     R4,A
0111 A3                INC     DPTR
0112 E0                MOVX    A,@DPTR
0113 FD                MOV     R5,A
0114 C3                CLR     C
0115 ED                MOV     A,R5
0116 9F                SUBB    A,R7
0117 EC                MOV     A,R4
0118 9E                SUBB    A,R6
0119 503F              JNC     ?C0029
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1210
011B 850083      E     MOV     DPH,?C_XBP
011E 850082      E     MOV     DPL,?C_XBP+01H
0121 A3                INC     DPTR
0122 E0                MOVX    A,@DPTR
0123 FE                MOV     R6,A
0124 A3                INC     DPTR
0125 E0                MOVX    A,@DPTR
0126 FF                MOV     R7,A
0127 8F82              MOV     DPL,R7
0129 8E83              MOV     DPH,R6
012B E0                MOVX    A,@DPTR
012C FF                MOV     R7,A
012D 900008            MOV     DPTR,#08H
0130 120000      E     LCALL   ?C?XBPOFF
0133 120000      E     LCALL   ?C?PLDXDATA
0136 900003            MOV     DPTR,#03H
0139 120000      E     LCALL   ?C?XBPOFF
013C E0                MOVX    A,@DPTR
013D FC                MOV     R4,A
013E A3                INC     DPTR
013F E0                MOVX    A,@DPTR
0140 FD                MOV     R5,A
0141 E9                MOV     A,R1
0142 2D                ADD     A,R5
0143 F9                MOV     R1,A
0144 EA                MOV     A,R2
0145 3C                ADDC    A,R4
0146 FA                MOV     R2,A
0147 EF                MOV     A,R7
0148 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1211
014B 900003            MOV     DPTR,#03H
014E 120000      E     LCALL   ?C?XBPOFF
0151 E4                CLR     A
0152 75F001            MOV     B,#01H
0155 120000      E     LCALL   ?C?IILDX
0158 80A4              SJMP    ?C0028
015A         ?C0029:
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 48  

                                           ; SOURCE LINE # 1214
015A 900007            MOV     DPTR,#07H
015D 120000      E     LCALL   ?C?XBPOFF
0160 E0                MOVX    A,@DPTR
0161 FF                MOV     R7,A
0162 120000      R     LCALL   _?USB_EnableOutEP
                                           ; SOURCE LINE # 1255
0165 800B              SJMP    ?C0031
0167         ?C0026:
                                           ; SOURCE LINE # 1257
                                           ; SOURCE LINE # 1258
0167 90000B            MOV     DPTR,#0BH
016A 120000      E     LCALL   ?C?XBPOFF
016D E4                CLR     A
016E F0                MOVX    @DPTR,A
016F A3                INC     DPTR
0170 E4                CLR     A
0171 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
0172         ?C0031:
                                           ; SOURCE LINE # 1261
0172 90000B            MOV     DPTR,#0BH
0175 120000      E     LCALL   ?C?XBPOFF
0178 E0                MOVX    A,@DPTR
0179 FE                MOV     R6,A
017A A3                INC     DPTR
017B E0                MOVX    A,@DPTR
017C FF                MOV     R7,A
                                           ; SOURCE LINE # 1262
017D         ?C0032:
017D 90000D            MOV     DPTR,#0DH
0180 120000      E     LCALL   ?C?ADDXBP
0183 22                RET     
             ; FUNCTION _?USB_ReadOutEP (END)

             ; FUNCTION _?USB_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 1287
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 90FFFF            MOV     DPTR,#0FFFFH
000B 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1291
000E 850083      E     MOV     DPH,?C_XBP
0011 850082      E     MOV     DPL,?C_XBP+01H
0014 A3                INC     DPTR
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 EF                MOV     A,R7
0018 D3                SETB    C
0019 9400              SUBB    A,#00H
001B 5003              JNC     $ + 5H
001D 020000      R     LJMP    ?C0034
0020 850083      E     MOV     DPH,?C_XBP
0023 850082      E     MOV     DPL,?C_XBP+01H
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 EF                MOV     A,R7
002A C3                CLR     C
002B 9409              SUBB    A,#09H
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 49  

002D 5075              JNC     ?C0034
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1293
002F 850083      E     MOV     DPH,?C_XBP
0032 850082      E     MOV     DPL,?C_XBP+01H
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 7E00              MOV     R6,#00H
003A EF                MOV     A,R7
003B 24FF              ADD     A,#0FFH
003D FF                MOV     R7,A
003E EE                MOV     A,R6
003F 34FF              ADDC    A,#0FFH
0041 FE                MOV     R6,A
0042 EF                MOV     A,R7
0043 C4                SWAP    A
0044 F8                MOV     R0,A
0045 540F              ANL     A,#0FH
0047 C8                XCH     A,R0
0048 68                XRL     A,R0
0049 FF                MOV     R7,A
004A EE                MOV     A,R6
004B C4                SWAP    A
004C 54F0              ANL     A,#0F0H
004E 48                ORL     A,R0
004F FE                MOV     R6,A
0050 850083      E     MOV     DPH,?C_XBP
0053 850082      E     MOV     DPL,?C_XBP+01H
0056 EF                MOV     A,R7
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1294
0058 850083      E     MOV     DPH,?C_XBP
005B 850082      E     MOV     DPL,?C_XBP+01H
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 EF                MOV     A,R7
0062 75F00B            MOV     B,#0BH
0065 A4                MUL     AB
0066 2400        E     ADD     A,#LOW USB_EP+01H
0068 F582              MOV     DPL,A
006A E4                CLR     A
006B 3400        E     ADDC    A,#HIGH USB_EP+01H
006D F583              MOV     DPH,A
006F E4                CLR     A
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1296
0071 850083      E     MOV     DPH,?C_XBP
0074 850082      E     MOV     DPL,?C_XBP+01H
0077 A3                INC     DPTR
0078 E0                MOVX    A,@DPTR
0079 FF                MOV     R7,A
007A EF                MOV     A,R7
007B 75F00B            MOV     B,#0BH
007E A4                MUL     AB
007F 2400        E     ADD     A,#LOW USB_EP+05H
0081 F582              MOV     DPL,A
0083 E4                CLR     A
0084 3400        E     ADDC    A,#HIGH USB_EP+05H
0086 F583              MOV     DPH,A
0088 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 50  

0089 FF                MOV     R7,A
008A 850083      E     MOV     DPH,?C_XBP
008D 850082      E     MOV     DPL,?C_XBP+01H
0090 E0                MOVX    A,@DPTR
0091 FE                MOV     R6,A
0092 EE                MOV     A,R6
0093 FD                MOV     R5,A
0094 7C00              MOV     R4,#00H
0096 ED                MOV     A,R5
0097 240E              ADD     A,#0EH
0099 FD                MOV     R5,A
009A EC                MOV     A,R4
009B 3460              ADDC    A,#060H
009D FC                MOV     R4,A
009E 8D82              MOV     DPL,R5
00A0 8C83              MOV     DPH,R4
00A2 EF                MOV     A,R7
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1297
                                           ; SOURCE LINE # 1298
00A4         ?C0034:
00A4 900002            MOV     DPTR,#02H
00A7 120000      E     LCALL   ?C?ADDXBP
00AA 22                RET     
             ; FUNCTION _?USB_EnableOutEP (END)

             ; FUNCTION _USB_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 1317
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1321
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 4043              JC      ?C0036
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5038              JNC     ?C0036
                                           ; SOURCE LINE # 1322
                                           ; SOURCE LINE # 1323
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 7E00              MOV     R6,#00H
0022 EF                MOV     A,R7
0023 24FF              ADD     A,#0FFH
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 34FF              ADDC    A,#0FFH
0029 FE                MOV     R6,A
002A EF                MOV     A,R7
002B C4                SWAP    A
002C F8                MOV     R0,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 51  

002D 540F              ANL     A,#0FH
002F C8                XCH     A,R0
0030 68                XRL     A,R0
0031 FF                MOV     R7,A
0032 EE                MOV     A,R6
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 48                ORL     A,R0
0037 FE                MOV     R6,A
0038 900000      R     MOV     DPTR,#ri
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1325
003D 900000      R     MOV     DPTR,#ri
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 7E00              MOV     R6,#00H
0044 EF                MOV     A,R7
0045 240E              ADD     A,#0EH
0047 FF                MOV     R7,A
0048 EE                MOV     A,R6
0049 3460              ADDC    A,#060H
004B FE                MOV     R6,A
004C 8F82              MOV     DPL,R7
004E 8E83              MOV     DPH,R6
0050 7408              MOV     A,#08H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1326
                                           ; SOURCE LINE # 1327
0053         ?C0036:
0053 22                RET     
             ; FUNCTION _USB_DisableOutEP (END)

             ; FUNCTION _USB_Force (BEGIN)
                                           ; SOURCE LINE # 1348
0000 900000      R     MOV     DPTR,#bState
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1349
                                           ; SOURCE LINE # 1350
0005 900000      R     MOV     DPTR,#bState
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906010            MOV     DPTR,#06010H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1351
000F 22                RET     
             ; FUNCTION _USB_Force (END)

             ; FUNCTION _?USB_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 1369
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 90FFFE            MOV     DPTR,#0FFFEH
000B 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1372
000E 850083      E     MOV     DPH,?C_XBP
0011 850082      E     MOV     DPL,?C_XBP+01H
0014 A3                INC     DPTR
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 52  

0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1374
0017 850083      E     MOV     DPH,?C_XBP
001A 850082      E     MOV     DPL,?C_XBP+01H
001D A3                INC     DPTR
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 D3                SETB    C
0023 9400              SUBB    A,#00H
0025 405F              JC      ?C0038
0027 850083      E     MOV     DPH,?C_XBP
002A 850082      E     MOV     DPL,?C_XBP+01H
002D A3                INC     DPTR
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 C3                CLR     C
0033 9409              SUBB    A,#09H
0035 504F              JNC     ?C0038
                                           ; SOURCE LINE # 1375
                                           ; SOURCE LINE # 1376
0037 850083      E     MOV     DPH,?C_XBP
003A 850082      E     MOV     DPL,?C_XBP+01H
003D A3                INC     DPTR
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 EF                MOV     A,R7
0044 24FF              ADD     A,#0FFH
0046 FF                MOV     R7,A
0047 EE                MOV     A,R6
0048 34FF              ADDC    A,#0FFH
004A FE                MOV     R6,A
004B EF                MOV     A,R7
004C C4                SWAP    A
004D F8                MOV     R0,A
004E 540F              ANL     A,#0FH
0050 C8                XCH     A,R0
0051 68                XRL     A,R0
0052 FF                MOV     R7,A
0053 EE                MOV     A,R6
0054 C4                SWAP    A
0055 54F0              ANL     A,#0F0H
0057 48                ORL     A,R0
0058 FE                MOV     R6,A
0059 850083      E     MOV     DPH,?C_XBP
005C 850082      E     MOV     DPL,?C_XBP+01H
005F EF                MOV     A,R7
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1377
0061 850083      E     MOV     DPH,?C_XBP
0064 850082      E     MOV     DPL,?C_XBP+01H
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 7E00              MOV     R6,#00H
006B EF                MOV     A,R7
006C 240E              ADD     A,#0EH
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 53  

006E FF                MOV     R7,A
006F EE                MOV     A,R6
0070 3460              ADDC    A,#060H
0072 FE                MOV     R6,A
0073 8F82              MOV     DPL,R7
0075 8E83              MOV     DPH,R6
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 5410              ANL     A,#010H
007C FF                MOV     R7,A
007D 850083      E     MOV     DPH,?C_XBP
0080 850082      E     MOV     DPL,?C_XBP+01H
0083 A3                INC     DPTR
0084 EF                MOV     A,R7
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1378
0086         ?C0038:
                                           ; SOURCE LINE # 1380
0086 850083      E     MOV     DPH,?C_XBP
0089 850082      E     MOV     DPL,?C_XBP+01H
008C A3                INC     DPTR
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
                                           ; SOURCE LINE # 1381
008F         ?C0039:
008F 900003            MOV     DPTR,#03H
0092 120000      E     LCALL   ?C?ADDXBP
0095 22                RET     
             ; FUNCTION _?USB_GetEPAckState (END)

             ; FUNCTION _USB_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 1406
0000 900000      R     MOV     DPTR,#powerStatus
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1407
                                           ; SOURCE LINE # 1408
0005 900000      R     MOV     DPTR,#powerStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0040
                                           ; SOURCE LINE # 1409
                                           ; SOURCE LINE # 1410
000D 900000      E     MOV     DPTR,#USB_deviceStatus
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4401              ORL     A,#01H
0015 FF                MOV     R7,A
0016 900000      E     MOV     DPTR,#USB_deviceStatus
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1411
001B 22                RET     
001C         ?C0040:
                                           ; SOURCE LINE # 1413
                                           ; SOURCE LINE # 1414
001C 900000      E     MOV     DPTR,#USB_deviceStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   02/21/2017 15:19:24 PAGE 54  

0021 EF                MOV     A,R7
0022 54FE              ANL     A,#0FEH
0024 FF                MOV     R7,A
0025 900000      E     MOV     DPTR,#USB_deviceStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1415
                                           ; SOURCE LINE # 1416
002A         ?C0042:
002A 22                RET     
             ; FUNCTION _USB_SetPowerStatus (END)

             ; FUNCTION USB_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 1461
                                           ; SOURCE LINE # 1462
                                           ; SOURCE LINE # 1463
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1464
0005 900000      E     MOV     DPTR,#USB_deviceStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0043
                                           ; SOURCE LINE # 1465
                                           ; SOURCE LINE # 1466
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1467
001A         ?C0043:
                                           ; SOURCE LINE # 1469
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 1470
001F         ?C0044:
001F 22                RET     
             ; FUNCTION USB_RWUEnabled (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2418    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
